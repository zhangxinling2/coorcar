# 微信租车程序

## go编程思想

### 接口

对于接口变量，变量包含当前接口实现者的类型和值。类型可以通过switch或断言来判断。

接口变量自带指针，所以虽然接口变量都是用值传递，但用到的都是里面的指针。

实现String接口，可以在输出时把go自己的输出换成String中自定义的输出

Read和Write接口，可以用在任何需要Read和Write的地方，比如文件，网络等。

### 函数与闭包

一个函数包括局部变量和自由变量，自由变量还可能连接结构，不断连接，把所有的连接包含，最终包括函数和所有的连接就是闭包。

### 服务器统一出错处理

把业务代码提取出来，让它返回error，定义一个appHandler类型和一个处理它的函数

```go
type appHandler func(writer http.ResponseWriter,request *http.Resquest)error
func errWrapper(handler appHandler)func(writer http.ResponseWriter,request *http.Resquest)
```

这样业务代码全部作为appHandler用errWrapper做处理，在errWrapper返回的func中使用switch去处理错误。

总控中如果HandleFunc处理的路径，而方法中使用URL.Path(len("..."))，不一致的话，会发生panic，但是程序并没有退出，因为http作为保护，做了一个recover，在errWrapper中defer一个func，这个func中r:=recover()可以去捕捉panic使程序在panic时不会退出。

要是想给用户展示特定的错误，完全可以自定义一个用户错误接口，可以用一个string来实现这个接口，在错误出现时去判断这个错误的类型是否属于这个接口。

```go
type userErr interface {
   error
   Message() string
}

type useError string
func (e useError) Error() string {
	return e.Message()
}
func (e useError) Message() string {
	return string(e)
}
			if userErr, ok := err.(userErr); ok {
				http.Error(writer, userErr.Message(), http.StatusBadRequest)
				return
			}
```

### 使用pprof调优

使用go test -bench . 进行性能测试

使用go test -bench . -cpuprofile cpu.out 生成cpuprofile文件，使用 go tool pprof cpu.out就可以进入一个命令行，写入web就可以进入web查看。

### 生成文档

一般写完注释，命令行输入 godoc -http :6060就可以去客户端看文档。

通过Example写示例代码，它是一个特别的test，但是他可以作为示例程序。

使用output:来显示结果

### 并发编程

#### 协程

协程，非抢占式多任务处理，由协程主动交出控制权，而线程是抢占式。

协程是编译器层面的多任务而不是操作系统层面。

```go
var a [10]int
for i := 0; i < 10; i++ {
   go func() {
      for {
         a[i]++
      }
   }()
}
```

这种代码会导致越界错误，使用go run -race .....go去查看，这个越界错误是因为闭包，跳出循环时i为10，此时协程中就为a[10]++，所以出现了错误，传入i即可不出现越界错误。

如果是把a定义成11个数的数组，那么结果就是类似

[0 0 321 3119 568 506 486 2619 481 2666 5736284]

因为i是不断增加的，这样所有的协程都去增大相同的i。

![image-20231129074530192](C:\Users\K9\OneDrive\图片\go笔记\协程对比普通函数.png)

#### 调度器

goroutine可能的切换点

I/O,select;    channel;    等待锁;    函数调用;    runtime.Gosched()

```go
for i, channel := range channels {
   channel = make(chan int)
}
```

这样使用range是不会成功初始化channel的，因为for i, channel := range channels只会去创建数据的副本而不会去修改原来的值，channel是循环内的局部变量。

读channel时，使用range的话，close时，读完后就会跳出循环。

##### 通过通信共享内存，而不是通过共享内存去通信

#### 并发模式

##### 生成器

使用channel做生成器

```go
func msgGen() chan string {
	c := make(chan string)
	go func() {
		i := 0
		for {
			time.Sleep(time.Millisecond * 2000)
			c <- fmt.Sprintf("message %d", i)
			i++
		}
	}()
	return c
}
```

比如这样一个简易的消息生成器

###### 服务/任务

生成器就可以抽象的认为作为一个服务或者任务

同时等待多个服务：两种方法

第一种方法，开两个goroutine来接受数据

```go
func fanIn(c1, c2 chan string) chan string {
   c := make(chan string)
   go func() {
      for {
         c <- <-c1
      }
   }()
   go func() {
      for {
         c <- <-c2
      }
   }()
   return c
}
```

第二种方法，开一个goroutine并且用select接受

```go
func fanInBySelect(c1, c2 chan string) chan string {
   c := make(chan string)
   go func() {
      for {
         select {
         case m := <-c1:
            c <- m
         case m := <-c2:
            c <- m
         }
      }
   }()
   return c
}
```

当不确定channel个数时，使用第一种方法。但是当使用for range去接受消息时，因为这是goroutine，会先生成，直到在主程序中读值时才会去运行c<- <-ch,ch全局只有一份，继续运行for range，ch的值会被改掉。

如果想要正确使用只能去拷贝一份，在goroutine使用这个拷贝出来的channel，也可以使用传参，因为参数传递全是值拷贝。

###### 非阻塞等待

使用select来实现非阻塞等待

###### 超时等待

参数传入时间即可。

```go
func someWait(c chan string,timeout time.Duration) (string, bool) {
   select {
   case m := <-c:
      return m, true
   case <-time.After(timeout):
      return "", false
   default:
      return "", false
   }
}
```

###### 任务中断与优雅退出

```go
func msgGen(name string, done chan struct{}) chan string {
   c := make(chan string)
   go func() {
      i := 0
      for {
         select {
         case <-time.After(time.Millisecond * 500):
            c <- fmt.Sprintf("service %s message %d", name, i)
         case <-done:
            fmt.Println("cleaning up")
            done<-struct{}{}//通知优雅退出已经完成
            return
         }
         i++
      }
   }()
   return c
}
```

添加一个退出channel即可

#### 广度优先走迷宫算法

循环创建二维slice

使用slice来实现队列

用fscanf读取文件

对point进行抽象

### gin

#### gin

go get -u github.com/gin-gonic/gin

#### middle

##### 日志

go get -u go.uber.org/zap

在NewProduction()后

使用Gin的Use来

```
r.Use(func(c *gin.Context)){
s:=time.Now()
    c.Next()
    //这样所有的处理都在这里
	logger.Info("incoming request",zap.String("path",c.Request.URL.Path)，zap.Int("status",c.Write.Status()),zap.Duration("elapsed",time.Now().Sub(s)),
	//可use多个
	func(c *gin.Context)){}
}
```

## 租辆酷车小程序与TypeScript

### 第一个小程序

#### 账号配置

前往微信公众平台进行小程序注册，并且补充小程序信息和类目。下载微信开发者工具创建项目

### vscode

下载vscode并且安装插件

### 微信小程序运行机制分析

#### 配置

app.json中

pages是小程序的页面，所有页面都要在这里注册。

window是窗口的配置。

在微信开发文档中都有说明

[微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html)

#### 运行与setData渲染

一个页面的结构与正常页面差不多，一个wxml与html相似，一个wxss与css相似，一个ts与js相似，还有一个json配置

如果要修改数据，小程序中要使用setData来修改

有进入场景，页面路径，和页面参数。

在不同的场景下可以定义不同的页面路径和页面参数。

setData:逻辑层ts将数据处理完成后通过setData将数据传到渲染层webview.webview通过事件路由到ts中执行方法。

#### 页面及app生命周期

##### App

OnLaunch

OnShow

OnHide

##### 页面

OnLoad

OnReady

OnShow

OnHide

OnUnload

navicateTo是添加页面进页面栈产生回退按钮，redirectTo是销毁当前页面进入下个页面可能产生home按钮，回退是通过页面栈来的。

#### 技术难点分析

1.地图能不能嵌入，车子显示等都是未知的；2.垂直导航；3.登录；4.用户及行程数据数据存储；5.驾照图片识别；6.驾照图片存储；

地图，驾照图片识别必定使用第三方依赖，而其他都属于工作量和算法，比如垂直导航就属于算法。首先要解决的就是第三方依赖。

#### 为小程序添加地图组件

只需要加一个map组件，这个组件同样在文档中有。

前端尝试位置移动。

数据来源：docker镜像

存在高精度GPS测试数据，预配置的mongodb环境，预配置的rabbitmq环境，辅助api。

直接docker pull ccr.ccs.tencentyun.com/coolcar/coolenv拉取镜像

这个镜像有一个ICODE保护，获取ICODE后docker run -e ICODE=... 去运行

### TypeScript

#### 安装

安装nodejs，nodejs是js的运行环境

安装后有npm命令，npm是node环境下的包管理器。

npm install -g typescript安装typescript,-g是为所有用户安装

也可运行npx tsc，npx是运行，如果安装了就直接运行机器上的，如果没安装就会去下载。

npm get registry是当前的镜像地址

使用npm config set registry https://registry.npmmirror.com  国内镜像就可以把镜像设置为国内。

#### 代码目录

目录下创建wx(小程序),server(服务器),admin(管理员界面),deployment(部署脚本)

wx的package.json中，devDependencies中存放的是项目的依赖，使用npm install 会自动去寻找这些包

#### 基础

[TypeScript: JavaScript With Syntax For Types. (typescriptlang.org)](https://www.typescriptlang.org/)

大部分语法可以在playground下去做

##### 数据类型

一般使用let去定义变量，如果赋值不同的类型值，会报错，但是在js中是可以运行的，js是弱类型语言。

定义类型时，可以在变量后面加上类型名称。数组是number类型，不区分int和double。

###### literal type

`let answer: 'yes'|'no'|'maybe'='maybe'`

这样可以限定变量的值

可以把answer赋值给一个字符串变量，但是不能再把变量重新赋值回answer。

一个变量可以有不同类型的literal type，赋值给一个新变量时，如果需要给声明类型的新变量赋值，新变量要符合literal type。

###### any

```typescript
let b:any='a'
b=2
b={}
b.name='name'
```

b就是动态变量

###### undefined

也是一种类型。

##### 逻辑控制

与其他语言基本一致。

不过判断相等一律用===和!==  因为==行为很怪。

if-else，如果在if-else条件中判断变量的类型，就可以在作用域中去使用这个类型的方法。

也支持try catch throw

##### 枚举

typescript所特有

enum 枚举名{

值

}

打印时如果不想打印值而是打印值的名称，可以使用中括号

```typescript
enum HttpStatus{
    Ok =200,
    NotFound=404,
    InternalError=500,
}
function print(s: HttpStatus){
    console.log(HttpStatus[s])
}
```



##### 可选参数

变量名字后加?代表可选参数

#### 高级

##### 函数式编程

箭头函数和this间有一些坑

对象类型参数能解决bool参数问题，因为传入bool可能不知道bool的具体意义，所以传入一个对象，给bool起一个名字以明确bool的意义。

###### 闭包

```typescript
function createCompare(p:{smallerFirst:boolean}){
    if(p.smallerFirst){
        return (a:number,b:number)=>a-b
    }else{
        return (a:number,b:number)=>b-a
    }
}
function loggingCompare(logger:(a:number,b:number)=>void,comp:(a:number,b:number)=>number){
    return (a:number,b:number)=>{
        logger(a,b)
        return comp(a,b)
    }
}
function processArray(a:number[]){
    let compCount=0
    const logger=(a:number,b:number)=>{
        //console.log('comparing',a,b)
        compCount++
    }
    const comp=createCompare({smallerFirst:true});
    a.sort(loggingCompare(logger,comp))
    return compCount
}
let a = [5,2,1,6,8,10,5,25,16,24,11]
const compCount=processArray(a)
console.log('compare count',compCount)
```

典型的闭包与无副作用函数式编程

logger函数携带compCount形成了一个闭包，这样计数比较就不需要定义一个全局变量，每次计数后需要清零。compCount这个变量的声明周期跟着logger走，而不是仅限于processArray。

###### 部分应用函数

有了闭包后就可以进行部分应用函数。应用部分应用函数可以将函数很好的和第三方去整合。

如果我有一个函数需要两个参数，可以建立一个单参数函数，另一个参数以闭包的形式放在整个函数体中，第二个参数就是单参数函数本身的一个参数。

```typescript
function isGoodNumber(goodFactory:number,v:number){
    return v%goodFactory===0
}
function filterArray(a:number[],f:(v:number)=>boolean){
    return a.filter(f)
}
const factory=2
let a = [5,2,1,6,8,10,5,25,16,24,11]
console.log(filterArray(a,(v)=>isGoodNumber(factory,v)))
```

也就是固定一个参数的值，然后用一个部分参数的函数去调用这个函数。

```typescript
function isGoodNumber(goodFactory:number,v:number){
    return v%goodFactory===0
}
function filterArray(a:number[],f:(v:number)=>boolean){
    return a.filter(f)
}
function ApplyPartial(f:(a:number,b:number)=>boolean,a:number){
    return (b:number)=>f(a,b)
}
const factory=2
let a = [5,2,1,6,8,10,5,25,16,24,11]
console.log(filterArray(a,ApplyPartial(isGoodNumber,factory)))
```

###### 总结

函数是一等公民。

高阶函数

闭包

部分应用函数

满足这些就是函数式编程风格

无副作用：函数中不改变全局变量值，不输出等等

引用透明性：console.log(5)与console.log(add(2,3))要一致，如果add中有一些输出之类的就不满足

惰性计算:都到最后才计算

再满足这些就是函数式编程

###### 函数式编程在微信小程序中应用

UI线程是单线程：

这是一个主循环，主循环一般不做事，它会去看有什么事件，根据事件不同会分发给某个函数去做处理。

![image-20231213215737698](C:\Users\K9\OneDrive\图片\go笔记\UI线程介绍.png)

比如getUserInfo不使用const userInfo=getUserInfo是因为getUserInfo是个网络请求，如果出现问题const userInfo=getUserInfo会阻塞住UI主线程。所以getUserInfo参数中如果成功则触发回调。

设置一个函数使其setData 50000次，再onload中调用，发现此时点击头像不管用，数字一直在增加。如果想一边setData，一边可以点击头像执行点击头像的方法。

所以是因为在onload中执行setData,点击事件要排队，所以不会触发点击事件。可以在setData的过程中，使用回调，成功了再执行下一次更新。这样会很耗资源，但是页面活过来了。

```typescript
updataMoto(){
      this.data.count++
      if(this.data.count<10000){
        this.setData({
          motto: `update count: ${this.data.count}`,
        },
          () => {
            this.updataMoto()
          })
      }
    },
```

但是像这样，页面的数据就需要维护count这样一个状态。如何改进为函数式编程？

```typescript
    updataMoto(){
      let shouldStop=false
      setTimeout(() => {
         shouldStop=true
       }, 10000);
      let count=0
      const update=()=>{
        count++
        if(!shouldStop){
          this.setData({
            motto: `update count: ${count}`,
          },
            () => {
              update()
            })
        }
      }
      update()
    },
```

原本updateMoto的内容相当于一个循环体，所以用一个函数变量把它包起来，之后在外面定义count即可。

如果把()=>换为function，这里this会报错为any指代不明，所以一般使用箭头函数。如果想使用function，就在updata外that=this将this给存下来。

