# 微信租车程序

## go编程思想

### 接口

对于接口变量，变量包含当前接口实现者的类型和值。类型可以通过switch或断言来判断。

接口变量自带指针，所以虽然接口变量都是用值传递，但用到的都是里面的指针。

实现String接口，可以在输出时把go自己的输出换成String中自定义的输出

Read和Write接口，可以用在任何需要Read和Write的地方，比如文件，网络等。

### 函数与闭包

一个函数包括局部变量和自由变量，自由变量还可能连接结构，不断连接，把所有的连接包含，最终包括函数和所有的连接就是闭包。

### 服务器统一出错处理

把业务代码提取出来，让它返回error，定义一个appHandler类型和一个处理它的函数

```go
type appHandler func(writer http.ResponseWriter,request *http.Resquest)error
func errWrapper(handler appHandler)func(writer http.ResponseWriter,request *http.Resquest)
```

这样业务代码全部作为appHandler用errWrapper做处理，在errWrapper返回的func中使用switch去处理错误。

总控中如果HandleFunc处理的路径，而方法中使用URL.Path(len("..."))，不一致的话，会发生panic，但是程序并没有退出，因为http作为保护，做了一个recover，在errWrapper中defer一个func，这个func中r:=recover()可以去捕捉panic使程序在panic时不会退出。

要是想给用户展示特定的错误，完全可以自定义一个用户错误接口，可以用一个string来实现这个接口，在错误出现时去判断这个错误的类型是否属于这个接口。

```go
type userErr interface {
   error
   Message() string
}

type useError string
func (e useError) Error() string {
	return e.Message()
}
func (e useError) Message() string {
	return string(e)
}
			if userErr, ok := err.(userErr); ok {
				http.Error(writer, userErr.Message(), http.StatusBadRequest)
				return
			}
```

### 使用pprof调优

使用go test -bench . 进行性能测试

使用go test -bench . -cpuprofile cpu.out 生成cpuprofile文件，使用 go tool pprof cpu.out就可以进入一个命令行，写入web就可以进入web查看。

### 生成文档

一般写完注释，命令行输入 godoc -http :6060就可以去客户端看文档。

通过Example写示例代码，它是一个特别的test，但是他可以作为示例程序。

使用output:来显示结果

### 并发编程

#### 协程

协程，非抢占式多任务处理，由协程主动交出控制权，而线程是抢占式。

协程是编译器层面的多任务而不是操作系统层面。

```go
var a [10]int
for i := 0; i < 10; i++ {
   go func() {
      for {
         a[i]++
      }
   }()
}
```

这种代码会导致越界错误，使用go run -race .....go去查看，这个越界错误是因为闭包，跳出循环时i为10，此时协程中就为a[10]++，所以出现了错误，传入i即可不出现越界错误。

如果是把a定义成11个数的数组，那么结果就是类似

[0 0 321 3119 568 506 486 2619 481 2666 5736284]

因为i是不断增加的，这样所有的协程都去增大相同的i。

![image-20231129074530192](C:\Users\K9\OneDrive\图片\go笔记\coolcar\协程对比普通函数.png)

#### 调度器

goroutine可能的切换点

I/O,select;    channel;    等待锁;    函数调用;    runtime.Gosched()

```go
for i, channel := range channels {
   channel = make(chan int)
}
```

这样使用range是不会成功初始化channel的，因为for i, channel := range channels只会去创建数据的副本而不会去修改原来的值，channel是循环内的局部变量。

读channel时，使用range的话，close时，读完后就会跳出循环。

##### 通过通信共享内存，而不是通过共享内存去通信

#### 并发模式

##### 生成器

使用channel做生成器

```go
func msgGen() chan string {
	c := make(chan string)
	go func() {
		i := 0
		for {
			time.Sleep(time.Millisecond * 2000)
			c <- fmt.Sprintf("message %d", i)
			i++
		}
	}()
	return c
}
```

比如这样一个简易的消息生成器

###### 服务/任务

生成器就可以抽象的认为作为一个服务或者任务

同时等待多个服务：两种方法

第一种方法，开两个goroutine来接受数据

```go
func fanIn(c1, c2 chan string) chan string {
   c := make(chan string)
   go func() {
      for {
         c <- <-c1
      }
   }()
   go func() {
      for {
         c <- <-c2
      }
   }()
   return c
}
```

第二种方法，开一个goroutine并且用select接受

```go
func fanInBySelect(c1, c2 chan string) chan string {
   c := make(chan string)
   go func() {
      for {
         select {
         case m := <-c1:
            c <- m
         case m := <-c2:
            c <- m
         }
      }
   }()
   return c
}
```

当不确定channel个数时，使用第一种方法。

但是当使用for range去接受消息时，因为这是goroutine，会先生成，直到在主程序中读值时才会去运行c<- <-ch,ch全局只有一份，继续运行for range，ch的值会被改掉。

如果想要正确使用只能去拷贝一份，在goroutine使用这个拷贝出来的channel，也可以使用传参，因为参数传递全是值拷贝。

###### 非阻塞等待

使用select来实现非阻塞等待

###### 超时等待

参数传入时间即可。

```go
func someWait(c chan string,timeout time.Duration) (string, bool) {
   select {
   case m := <-c:
      return m, true
   case <-time.After(timeout):
      return "", false
   default:
      return "", false
   }
}
```

###### 任务中断与优雅退出

```go
func msgGen(name string, done chan struct{}) chan string {
   c := make(chan string)
   go func() {
      i := 0
      for {
         select {
         case <-time.After(time.Millisecond * 500):
            c <- fmt.Sprintf("service %s message %d", name, i)
         case <-done:
            fmt.Println("cleaning up")
            done<-struct{}{}//通知优雅退出已经完成
            return
         }
         i++
      }
   }()
   return c
}
```

添加一个退出channel即可

#### 广度优先走迷宫算法

循环创建二维slice

使用slice来实现队列

用fscanf读取文件

对point进行抽象

### gin

#### gin

go get -u github.com/gin-gonic/gin

#### middle

##### 日志

go get -u go.uber.org/zap

在NewProduction()后

使用Gin的Use来

```
r.Use(func(c *gin.Context)){
s:=time.Now()
    c.Next()
    //这样所有的处理都在这里
	logger.Info("incoming request",zap.String("path",c.Request.URL.Path)，zap.Int("status",c.Write.Status()),zap.Duration("elapsed",time.Now().Sub(s)),
	//可use多个
	func(c *gin.Context)){}
}
```

## 租辆酷车小程序与TypeScript

### 第一个小程序

#### 账号配置

前往微信公众平台进行小程序注册，并且补充小程序信息和类目。下载微信开发者工具创建项目

### vscode

下载vscode并且安装插件

### 微信小程序运行机制分析

#### 配置

app.json中

pages是小程序的页面，所有页面都要在这里注册。

window是窗口的配置。

在微信开发文档中都有说明

[微信开放文档 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html)

#### 运行与setData渲染

一个页面的结构与正常页面差不多，一个wxml与html相似，一个wxss与css相似，一个ts与js相似，还有一个json配置

如果要修改数据，小程序中要使用setData来修改

有进入场景，页面路径，和页面参数。

在不同的场景下可以定义不同的页面路径和页面参数。

setData:逻辑层ts将数据处理完成后通过setData将数据传到渲染层webview.webview通过事件路由到ts中执行方法。

#### 页面及app生命周期

##### App

OnLaunch

OnShow

OnHide

##### 页面

OnLoad

OnReady

OnShow

OnHide

OnUnload

navicateTo是添加页面进页面栈产生回退按钮，redirectTo是销毁当前页面进入下个页面可能产生home按钮，回退是通过页面栈来的。

#### 技术难点分析

1.地图能不能嵌入，车子显示等都是未知的；2.垂直导航；3.登录；4.用户及行程数据数据存储；5.驾照图片识别；6.驾照图片存储；

地图，驾照图片识别必定使用第三方依赖，而其他都属于工作量和算法，比如垂直导航就属于算法。首先要解决的就是第三方依赖。

#### 为小程序添加地图组件

只需要加一个map组件，这个组件同样在文档中有。

前端尝试位置移动。

数据来源：docker镜像

存在高精度GPS测试数据，预配置的mongodb环境，预配置的rabbitmq环境，辅助api。

直接docker pull ccr.ccs.tencentyun.com/coolcar/coolenv拉取镜像

这个镜像有一个ICODE保护，获取ICODE后docker run -e ICODE=... 去运行

### TypeScript

#### 安装

安装nodejs，nodejs是js的运行环境

安装后有npm命令，npm是node环境下的包管理器。

npm install -g typescript安装typescript,-g是为所有用户安装

也可运行npx tsc，npx是运行，如果安装了就直接运行机器上的，如果没安装就会去下载。

npm get registry是当前的镜像地址

使用npm config set registry https://registry.npmmirror.com  国内镜像就可以把镜像设置为国内。

#### 代码目录

目录下创建wx(小程序),server(服务器),admin(管理员界面),deployment(部署脚本)

wx的package.json中，devDependencies中存放的是项目的依赖，使用npm install 会自动去寻找这些包

#### 基础

[TypeScript: JavaScript With Syntax For Types. (typescriptlang.org)](https://www.typescriptlang.org/)

大部分语法可以在playground下去做

##### 数据类型

一般使用let去定义变量，如果赋值不同的类型值，会报错，但是在js中是可以运行的，js是弱类型语言。

定义类型时，可以在变量后面加上类型名称。数组是number类型，不区分int和double。

###### literal type

`let answer: 'yes'|'no'|'maybe'='maybe'`

这样可以限定变量的值

可以把answer赋值给一个字符串变量，但是不能再把变量重新赋值回answer。

一个变量可以有不同类型的literal type，赋值给一个新变量时，如果需要给声明类型的新变量赋值，新变量要符合literal type。

###### any

```typescript
let b:any='a'
b=2
b={}
b.name='name'
```

b就是动态变量

###### undefined

也是一种类型。

##### 逻辑控制

与其他语言基本一致。

不过判断相等一律用===和!==  因为==行为很怪。

if-else，如果在if-else条件中判断变量的类型，就可以在作用域中去使用这个类型的方法。

也支持try catch throw

##### 枚举

typescript所特有

enum 枚举名{

值

}

打印时如果不想打印值而是打印值的名称，可以使用中括号

```typescript
enum HttpStatus{
    Ok =200,
    NotFound=404,
    InternalError=500,
}
function print(s: HttpStatus){
    console.log(HttpStatus[s])
}
```



##### 可选参数

变量名字后加?代表可选参数

#### 高级

##### 函数式编程

箭头函数和this间有一些坑

对象类型参数能解决bool参数问题，因为传入bool可能不知道bool的具体意义，所以传入一个对象，给bool起一个名字以明确bool的意义。

###### 闭包

```typescript
function createCompare(p:{smallerFirst:boolean}){
    if(p.smallerFirst){
        return (a:number,b:number)=>a-b
    }else{
        return (a:number,b:number)=>b-a
    }
}
function loggingCompare(logger:(a:number,b:number)=>void,comp:(a:number,b:number)=>number){
    return (a:number,b:number)=>{
        logger(a,b)
        return comp(a,b)
    }
}
function processArray(a:number[]){
    let compCount=0
    const logger=(a:number,b:number)=>{
        //console.log('comparing',a,b)
        compCount++
    }
    const comp=createCompare({smallerFirst:true});
    a.sort(loggingCompare(logger,comp))
    return compCount
}
let a = [5,2,1,6,8,10,5,25,16,24,11]
const compCount=processArray(a)
console.log('compare count',compCount)
```

典型的闭包与无副作用函数式编程

logger函数携带compCount形成了一个闭包，这样计数比较就不需要定义一个全局变量，每次计数后需要清零。compCount这个变量的声明周期跟着logger走，而不是仅限于processArray。

###### 部分应用函数

有了闭包后就可以进行部分应用函数。应用部分应用函数可以将函数很好的和第三方去整合。

如果我有一个函数需要两个参数，可以建立一个单参数函数，另一个参数以闭包的形式放在整个函数体中，第二个参数就是单参数函数本身的一个参数。

```typescript
function isGoodNumber(goodFactory:number,v:number){
    return v%goodFactory===0
}
function filterArray(a:number[],f:(v:number)=>boolean){
    return a.filter(f)
}
const factory=2
let a = [5,2,1,6,8,10,5,25,16,24,11]
console.log(filterArray(a,(v)=>isGoodNumber(factory,v)))
```

也就是固定一个参数的值，然后用一个部分参数的函数去调用这个函数。

```typescript
function isGoodNumber(goodFactory:number,v:number){
    return v%goodFactory===0
}
function filterArray(a:number[],f:(v:number)=>boolean){
    return a.filter(f)
}
function ApplyPartial(f:(a:number,b:number)=>boolean,a:number){
    return (b:number)=>f(a,b)
}
const factory=2
let a = [5,2,1,6,8,10,5,25,16,24,11]
console.log(filterArray(a,ApplyPartial(isGoodNumber,factory)))
```

###### 总结

函数是一等公民。

高阶函数

闭包

部分应用函数

满足这些就是函数式编程风格

无副作用：函数中不改变全局变量值，不输出等等

引用透明性：console.log(5)与console.log(add(2,3))要一致，如果add中有一些输出之类的就不满足

惰性计算:都到最后才计算

再满足这些就是函数式编程

###### 函数式编程在微信小程序中应用

UI线程是单线程：

这是一个主循环，主循环一般不做事，它会去看有什么事件，根据事件不同会分发给某个函数去做处理。

![image-20231213215737698](C:\Users\K9\OneDrive\图片\go笔记\coolcar\UI线程介绍.png)

比如getUserInfo不使用const userInfo=getUserInfo是因为getUserInfo是个网络请求，如果出现问题const userInfo=getUserInfo会阻塞住UI主线程。所以getUserInfo参数中如果成功则触发回调。

设置一个函数使其setData 50000次，再onload中调用，发现此时点击头像不管用，数字一直在增加。如果想一边setData，一边可以点击头像执行点击头像的方法。

所以是因为在onload中执行setData,点击事件要排队，所以不会触发点击事件。可以在setData的过程中，使用回调，成功了再执行下一次更新。这样会很耗资源，但是页面活过来了。

```typescript
updataMoto(){
      this.data.count++
      if(this.data.count<10000){
        this.setData({
          motto: `update count: ${this.data.count}`,
        },
          () => {
            this.updataMoto()
          })
      }
    },
```

但是像这样，页面的数据就需要维护count这样一个状态。如何改进为函数式编程？

```typescript
    updataMoto(){
      let shouldStop=false
      setTimeout(() => {
         shouldStop=true
       }, 10000);
      let count=0
      const update=()=>{
        count++
        if(!shouldStop){
          this.setData({
            motto: `update count: ${count}`,
          },
            () => {
              update()
            })
        }
      }
      update()
    },
```

原本updateMoto的内容相当于一个循环体，所以用一个函数变量把它包起来，之后在外面定义count即可。

如果把()=>换为function，这里this会报错为any指代不明，所以一般使用箭头函数。如果想使用function，就在updata外that=this将this给存下来。

##### 数组的变换

foreach朴素易懂，但是有副作用

```typescript
const a =[1,2,3,4]
const b=a.map(v=>v*v)
const sum = b.reduce((s,v)=>s+=v)
console.log(b)
console.log(sum)
```

map对数组中所有数据运用传进的函数

map和reduce是无副作用的。

##### promise

###### 回调函数缺点

所有前端都由四步构成，发起请求，事件处理函数结束(发起请求后就结束),请求结束，进入回调。请求结束后就进入回调函数。做一件事，有可能需要拿第一个请求的结果去发第二个请求，也可能同时需要几个请求的结果去发起一个请求，通过回调函数的写法就造成callback hell

###### Promis创建和使用

```typescript
function add(a:number,b:number):number{
    return a+b
}
console.log(add(2,3))
```

这是一个典型的同步，要等return 2+3后才会输出，如果add中有很复杂的操作，比如发到服务器，会有等待。所以要采用回调函数。

```typescript
function add(a:number,b:number,callback:(res:number)=>void):void{
    setTimeout(()=>{
        callback(a+b)
    },2000)
}
add(2,3,res=>{
    console.log('2+3',res)
    add(res,4,res2=>{
        console.log('2+3+4',res)
    })
})
```

这样采用回调函数 setTimeout，两秒执行一次callback，add中执行一个连加，这样就模拟出来微信小程序中的getUserInfo的连调。但是这样用起来有些麻烦。

使用Promise

```typescript
function add(a:number,b:number):Promise<number>{
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve(a+b)
        },2000)
    })
}
add(2,3).then(res=>{
        console.log('2+3',res)
        return add(res,4)}
    ).then(res=>{
        console.log('2+3+4',res)
    })
```

返回一个Promise，在函数中new Promise，它的参数是一个函数，这个函数的参数是resolve和reject这两个函数。在使用时，如果成功返回就使用resolve来出值，如果出错了，使用reject。返回Promise的函数在使用时后面可以加.then来进行后续处理，then返回的还是一个Promise。

Promise最大的好处就是串联，解决了callback hell问题。

###### 同时等待多个promise

现在像运行一个(3+4)*(4+5),两次相加是并行做的。等待两次想加的结果去做乘法。

使用Promise.all它的参数是一个promise数组。然后返回一个执行完的数组。const [a,b]=res就是将res数组展开赋值给a,b。

```typescript
function add(a:number,b:number):Promise<number>{
    return new Promise((resolve,reject)=>{
        if(b%17==0){
            reject(`bad number:${b}`)
        }
        setTimeout(()=>{
            resolve(a+b)
        },2000)
    })
}
function mul(a:number,b:number):Promise<number>{
    return new Promise((resolve,reject)=>{
        resolve(a*b)
    })
}
//(2+3)*(4+5)
Promise.all([add(2,3),add(4,5)]).then(res=>{
    const [a,b]=res
    return mul(a,b)
}).then(res=>{
    console.log("final result",res)
})
```

Promise.all()是经常使用的，比如初始化时。

Promise.race()是只有一个运行完成即可。

###### 把小程序中的回调函数改写为Promise

getSetting改写，getUserInfo同理

```typescript
export function getSetting():Promise<WechatMiniprogram.GetSettingSuccessCallbackResult>{
  return new Promise((resolve,reject)=>{
    wx.getSetting({
      //success:res=>resolve(res),
      //res=>resolve(res)这是个函数，resolve本身也是个函数，res=>resolve(res)意思与直接resolve相同，reject同理
      success:resolve,
      fail:reject,
    })
  })
}
```

这样就可以改造。

```typescript
getSetting().then(res=>{
      if(res.authSetting['scope.userInfo']){
        return getUserInfo()
      }
      //如果没有权限就返回一个undefined的Promise
      return Promise.resolve(undefined)
    }).then(res=>{
      if(!res){
        return
      }
      this.globalData.userInfo=res?.userInfo
      //通知页面我获得了用户信息
      if(this.userInfoReadyCallback){
        this.userInfoReadyCallback(res)
      }
    })
```

这只是个实例，通常不必把所有请求都改为promise，可以把网络请求这种常用请求改为Promise。

###### 将通知页面获得信息改为Promise

比较容易解决小程序打开一直是白板的情况。增强功能，减少代码量。

三种方法通知：

1.回调函数:小程序中的代码。查看index.ts中的Onload发现先判断全局中有没有userInfo，获取userInfo的callback回的特别快时，会有。当userInfo不在而页面已经出来时就要设一个CallBack函数app.userInfoReadyCallback。		很不稳定，依赖逻辑正确性。无法支持两个页面。要通知两个页面就要去做成回调函数数组，就很麻烦，难以维护状态。

2.EventEmitter:js的标准，用来管理回调函数数组。主要用在一些自定义组件上。

3.Promise

1.  有权限的情况，已经给于过权限，直接去获取用户信息。

   这里page,page2都需要信息，是因为，小程序开启时并不一定在主页。由于Onload后可能回调还没有触发，信息回来后改如何通知setData?

![image-20231214212146112](C:\Users\K9\OneDrive\图片\go笔记\coolcar\微信小程序获取用户信息流程.png)

在globalData的文件中有一个userInfoReadyCallback?: WechatMiniprogram.GetUserInfoSuccessCallback,删掉。

globalData中的userInfo改为Promise类型

Promise<WechatMiniprogram.UserInfo>，这样userInfo.then，then中就是userInfo，这样在onLoad中就不需要去判断，而是直接使用.then即可。

```typescript
      app.globalData.userInfo.then(res=>{
        this.setData({
            userInfo:res,
            hasUserInfo:true
        })
      })
```

那么如何给userInfo赋值，在app.ts中的globalData去给它赋值.把之前的Promise版getSetting放进去。

```typescript
  globalData: {
      userInfo:new Promise((resolve, reject) => {
        getSetting().then(res=>{
            if(res.authSetting['scope.userInfo']){
              return getUserInfo()
            }
            //如果没有权限就返回一个undefined的Promise
            return Promise.resolve(undefined)
          }).then(res=>{
            if(!res){
              return
            }
            resolve(res.userInfo)
          }).catch(reject)
      })
  },
```

2.当没有授权时，要在index.ts的getUserInfo中去把userInfo赋值给globaldata中的userInfo，但是globalData中的为Promise，只能去resolve，所以去app.ts中定义两个函数变量，然后在new Promise中把resolve和reject存储进去，然后定义两个函数去执行这两个函数变量。把原本在app.ts中获取用户信息的操作放进onLaunch去做。这样就能在index.ts中使用定义的两个函数。

不过现在微信小程序已经改为GetUserProfile来获取用户信息，并且这个方法只能手动触发，所以，只能单独去缓存用户信息，读的时候从缓存的地方去读。

###### async/await异步函数 语法糖

await 就是等待结果，但是是异步等待，await add(2,3)就相当于add(2,3).then()。所以Promise可以通过await去使用。return的是一个Promise<>类型，所以使用这个函数的结果还是要用then去处理。

```typescript
async function calc(){
   const a = await add(2,3)
   const b = await add(4,5)
   const c = await add(a,b)
   return c
}
```

也可以await Promise.all([add(2,3),add(4,5]),因为await后面只需要Promise。

##### 类型相关

###### 接口

就是简单的描述一个类型，可以把它当成类，不过它的成员是可以有函数的。如果想要具体的对象中可以没有接口中限定的参数，接口中参数加上?即可。

使用let定义一个对象为接口类型是不会为这个对象分配空间的。可以通过类的实例或者直接{....}赋值去分配空间。

非空断言   ？    !代表一定有值，如果值为空那么程序就会挂掉。

接口扩展：在接口类型定义上加extends。

如果对象是两个接口的或，那么在使用时就要去判断这个对象到底是哪个接口，判断方法为，判断这个对象中接口独有的参数是不是undefined，如果不是，那么就可以确定是这个接口类型。

###### 类

```typescript
class Emplayee{
    private allocateBonus?:number
    // name:string=''
    // salary:number
    constructor(public name:string,public salary:number){
        this.name=name
        this.salary=salary
    }
    set bonus(v:number){
        this.allocateBonus=v
    }
}
const emp1=new Emplayee("john",2000)
emp1.bonus=20000
console.log(emp1)
```

继承仍然是extends

同样的的，类可以去实现接口

只要接口中的属性在类中全部存在即可。编译器会去一一对照。不加implements就是隐式实现，加就是显式实现。

###### 泛型

#### 前端知识速成

#####  打造第一个产品demo

这是一个展示demo。

###### 目标

包含产品的主要功能

展示的功能完整

无需后端

##### css入门

###### wxml

属性中有wx:if,else可以wx:if去判断,也可以可以使用block来实现。

```xml
<text wx:if="{{showPath}}">pages/learncss/learncss.wxml</text>
<block wx:else>
    <text>learn css</text>
</block>
```

for：在wxml中一般使用<view>

```xml
<view wx:for="{{values}}" wx:for-item="val" wx:key="*this">
    val is {{val}}
</view>
```

###### css选择器

选择我想要的元素，同时给这一批元素赋予样式。

样式：

<style>
    div {
        font-size:xx-large
    }
</style>

**三种选择方式**

这就是选中div，把它的字体设置为large

如果想设置固定的div，可以给它赋予一个id，就可以用#id去选择它。

如果想批量的设置，就给它们设置一个class，使用.class去选择它们。

**多个选择器组合**

如果class是"item blue"

+ .item仍然可以选中，只要class包含item就行。

+ 想单独选中可以通过.item.blue来选中。

+ .item div 就是选择有itemclass的div
+ div.blue 同样可以
+ 父子关系 .item div就是选择class为item的下的div儿子，如果儿子有class通用可以使用.item .stared,如果有多级儿子，.item >...就可以选择第一级儿子。

###### 控制元素位置

绝对单位px；相对单位rpx,em；百分比。百分比时是找父亲节点。

**缩进**

margin

border

padding

高度会加上这三个，如果想设置多少就是多少可以使用box-sizing:border-box。

**位置**

left

top

right

bottom

需要配上positon,如果父亲是relative，那么所有的儿子都会相对于父亲去放置。

**文本样式**

font-style

font-weight

text-align

折行

text-overflow：ellipses   省略号

white-space

**flex布局**



## 租车设计与研发

### 前端设计

#### 框架选择

##### 多端

wepu   mpvue  taro  uni-app，可以多平台发布

##### 组件库

weui  wux  vant

##### 原生

小程序本身迭代快，小程序及各框架都有坑，本项目没有多端需求。

##### 样式库

使用colorUI样式库。

使用样式库，要把样式拷到项目下才能去使用它。

把demo下的colorui文件夹复制到miniprogram下只需要其中的icon.wxss和main.wxss

接下来 在app.wxss中去@import它们

#### 首页地图页实现

map组件默认为300x150，铺满页面要设宽高为100%,page的高也要设为100%,不然map的高找不到。

##### 左侧两个按钮

行程记录，当前位置。

叠加两张图片。

图片从material design中找。

使用color-view去在map上叠加控件。

color-view支持嵌套color-view,color-image.可在color-view中使用button.

```xml
<map  
  id="map"
  latitude="{{location.latitude}}"
  longitude="{{location.longitude}}"
  scale="{{scale}}"
  setting="{{setting}}"
  enable-overlooking="{{isOverLooking}}"
  enable-3D="{{is3D}}"
  markers="{{markers}}">
  <cover-view class="icon-container">
    <cover-image src="/resources/account.png"></cover-image>
    <cover-image src="/resources/my_location.png"></cover-image>
  </cover-view>
  </map>
```

接下来就该调整样式。把两个图片放到map左上方。

接下来就给两个image绑定事件。

###### onMyLocationTap

location绑定onMyLocationTap事件。

```typescript
onMyLocationTap(){
    wx.getLocation({
      type:'gcj02',
      success:res=>{
        this.setData({
          location:{
            latitude:res.latitude,
            longitude:res.longitude,
          },
        })
      },
      fail:()=>{
        wx.showToast({
          icon:'none',
          title:'请前往设置页设置',
        })
      }
    })
  }
```

要在app.json中加上请求权限。

```json
  "permission": {
    "scope.userLocation": {
        "desc": "你的位置信息将用于租辆酷车"
    }
  },
```

##### 下侧按钮寻找车辆

再开一个cover-view class设置为btn-container bg-grey,接下来就该调位置。要使元素居中在css中并不容易，除非在一个flex容器中。所以在这里只能使用margin-left:75rpx。使用bottom:100rpx和position:absolute把这个放到底部。其中的文字要居中，这个cover-view display:flex，自己是个flex容器之后使用justify就可以让文字居中，这是随着flex方向的居中，在此基础上，align-items:center就可以使其纵向居中。

由于屏幕宽度固定位750rpx，但是高度是不固定的，所以百分比更合适。

#### 汽车位置移动

首先想到的就是setData,问题在于setData太过于频繁。

map还有别的api来设置。

添加一个函数moveCars,首先要拿到map去使用它的api。wx.createMapContext(id),translateMarker就是转换点，参数中有个animationEnd,用于结束动画的回调。为了持续的移动，把移动过程放进一个函数体中。需要一个全局变量来控制页面Hide时不去移动。

#### 扫码租车实现

点击按钮后，手机需要出现一个二维码，如果没有认证，那么需要弹出页面提交驾驶证资料，提交驾照后进行资料填写进行审查。

wx有wx.scanCode这个API来进行扫码。现在先简单的扫到二维码就跳转到register页面。进入register时有一个对话框解释进入页面的原因，这涉及组件的开发，之后到组件部分再来开发。

需要一个image和两个view来显示照片，相机图标和文字，它们要框在一起，因为在上传完照片后，他们都会消失，出现填写资料的页面。

接下来就要调整css。

##### 处理点击上传事件

###### 在整个view绑定点击上传事件。

实践中使用wx.chooseImage，现在已经弃用，使用chooseMedia,参数中的sizeType是原图还是压缩图，sourceType是从相册选还是照相机选。先什么都不加，直接success和fail输出一下内容。微信会生成临时地址。直接使用这个临时地址即可。

###### 在前端在block中显示图片。同样的是view包裹image。

显示图片后，下面要显示一个表单。表单也是参照colorUI中的表单。

###### 同样的，表单也需要view包裹。

拷贝过来后发现没有对齐。因为colorui中的.css有计算：

.cu-form-group .title {

 min-width: calc(4em + 30rpx);

}

就是title最小宽度为四个字符加上30rpx

选择器的内容，为自己定义的性别genders.	然后绑定上值改变函数。事件的值是通过e.detail.value送来的。

日期选择同样的改为自己需要的

上传驾驶证图片后，应该自动填写表单，所以应该在上传的方法中去setTimeout()去设置表单。

##### 提交审查

最下方加一个递交审查的按钮。

点击之后应该显示审查中，结束后如果失败显示重新审查的按钮，成功应该自动跳转到开锁页面。使用redirectTo去lock页面。

自然想到需要有一个状态位来转换三个状态(unsubmitted,pending vefired)来显示。审查中class设置为无效状态。

同样，上方表单在unsubmitted时也需要禁用。

为了审查结束表现的明显，在审查结束后再图片上叠加一个勾的图片。

##### 租车界面

上方是汽车图片加一段使用后把车停放在停车位内的相关提示。最下方是一个立即开锁的按钮。点击开锁后需要获取位置权限去开锁，显示开锁中，并之后跳转界面。

在中间可以设置一个展示头像，在这里获取头像权限，而不是在首页去要权限。先需要一个假头像，同样是去colorUI中去找。假头像下面加文字来引导用户点击。点击后去获取用户头像。

在头像旁边加一个开关，让用户可以选择是否去展示。

把开关存入localstorage中。使用setStorageSync传入key,value。

在这里获得权限后就可以在主页也去显示头像。

#### 行程中页面

点击立即开锁后，应该显示开锁中，完成后应该跳转到driving页面。

页面分为上方地图和下方面板。面板中有计时，费用，和结束行程按钮。

使面板在底部和地图在上，使用容器的反向排列来实现。地图使用flex-grow让地图填充满剩余部分。

之前使用getLocation，wx还有一个方法为startLocationUpdateBackground，这可以使微信通知我们位置发生变更。真实的操作发生在onLocationChanged。为了这里能够使用，在点击立即开锁时需要获取位置权限。

##### 滚动事件和费用

为了滚动时间，要去读秒，所以除了setupLocation还需要一个setupTimer来读秒。给elapsed设置formatDuration，实现这个函数将秒转化为标准格式。Math.floor(sec/3600)为小时。

费用先使用centPerSec来模拟，使用formatFee来计算，钱要按照分来算，以减少小数点。

#### 我的行程

mytrips页面

点击首页头像跳转到mytrips页面。使用navigateTo跳转。

小程序中要绑定一个事件的参数就在控件上加data-.....={{...}}后面是自定义。点击后e中有target和currentTarget，target就是当前点击的控件数据，currentTarget就是有bindTap的控件的数据。

##### swiper

轮播组件

swiper-item使用for循环找url去轮播图片，使用程序控制滑块可以使用current属性，bindchange在current改变时触发。在事件中可以使用source去判断图片因为什么而改变。如果没有source就是程序主动让他变得。

##### scroll-view

可滚动的view

##### 页面带参数跳转

在页面中显示驾驶资格未认证，之后点击可以跳转到认证界面。使用navigateTo。上传完回到此页面。



![image-20240102073759422](C:\Users\K9\OneDrive\图片\go笔记\coolcar\页面跳转流程图.png)

carid是扫码的结果，附带在url中

先从开锁页面开始加上参数。opt参数，弱类型，.不出东西，但是知道后可直接使用。开锁页面OnLoad的opt中包含carid,驾驶页面包含tripId，这是在开锁界面中生成。注册页面保存传进来的redirect，这是个变量，存储跳转的url，在onLicVerified中就可以去判断保存下来的变量。index中去跳转时加上redirect参数。redirect是lock页面，要带上carId参数。要对redirect进行转义，encodeURIComponent。

##### 页面跳转的强类型化重构

跳转中不再拼接字符串，重命名util文件为wxapi，在utils目录下新建routing把页面跳转的字符统一管理。命名空间定为routing，定义函数去return字符串，后面的参数传入接口来加入。

在接收的时候可以限定opt为Record<'trip_id',string>这样可以直接opt.trip_id来使用，这样就可以直接在函数内定义接口并赋值opt,因为此时opt已经明确内部含有trip_id。如果有多个参数可以Record<'trip_id'|'...',string>

中间register页面是比较麻烦的，因为redirect是可选地，此参数还要编码传入。这样RegisterOpts接口定义中就把redirect定义为可选参数。RegisterOpts是给接收的人使用的。再定义一个接口RegisterParams里面定义redirectURL，方法传入的是可选RegisterParams。

### 接入微服务grpc

#### vscode go配置

安装go插件后在vscode命令面板输入go:install去安装需要的东西。

#### grpc

可以看做服务端的一个框架。

发送请求时需要考虑使用什么协议？服务器地址？路径？参数？数据类型？编码？安全性？错误处理？

使用wx.request去发送http请求，但是这样发送没有任何保护，只要有一点输入错误就会导致失败，rpc就是为了解决此问题。

基于HTTP/2,与HTTP1协议相同。但是它的传输是二进制；流式传输(服务器生成数据就发送)；多路复用(复用建立的tcp连接)：Http1如果有两个请求要复用同一连接，必须等前面的请求响应完毕；安全性提升

方法只使用post

路径/Service/Method

参数 body

安全性：http2协议和header

数据 二进制数据流

数据结构 protoBuf

优点在于：高效的数据传输，语言无关的领域模型定义，可以一次定义服务，任何语言都可以使用。

#### protobuf编译器安装 

去github中找protobuf项目去找realease中的protoc去安装,之后去设置protoc的环境变量。

之后再去gRPC-Gateway按照说明安装。

#### protobuf使用

新建trip.proto来演示，安装vscode-proto3插件

##### Protobuf

```protobuf
syntax = "proto3";//代表使用proto3
package coolcar;//这个package是proto文件的package，作用不大
option go_package="coolcar/proto/gen/go;trippb";//代表生成的文件在coolcar/proto/gen/go路径下包名为trippb
message Location{
    double lagitude=1;
    double longitude=2;
}
enum TripStatus {
    IS_NOT_SPECITED=0;
    NOT_STARTED=1;
    IN_PROGRESS=2;
    FINISHED=3;
    PAID=4;
}
//描述Trip字段
message Trip{
    string start =1;//代表第一个字段是start，因为是二进制数据流，所以要这样告诉第几个字段是什么
    string end =2;
    int64 duration_sec=3;
    int64 fee_cent=4;
    Location start_pos=5;
    Location end_pos=6;
    repeated Location path_locations=7;//翻译到go会变成切片
    TripStatus status=8;
}
//服务定义
message GetTripRequest{
    string id=1;
}
message GetTripResponse{
    string id=1;
    Trip trip=2;
}
service TripService {
    rpc GetTrip (GetTripRequest) returns (GetTripResponse);
}
```

**protoc -I=. --go_out=paths=source_relative:gen/go trip.proto**

-I是输入路径  --go_out代表的是生成go类型的protobuf，paths是生成的路径source_relative代表相对路径， trip.proto代表要编译的文件。

就会生成一个trip.pb.go,包含了生成的代码。

编码和解码都同样是用marshal。

protobuf中每个字段都是可选的。**为了新旧系统同时存在，所以字段可选**，否则很容易挂掉。新服务中结构体字段多发到旧服务中，旧服务会忽略新增的字段。

反之因为是可选的，所以会默认填入0，与go零值完美衔接，所以**区分不了是填了0还是没填值**。

##### 微服务GRPC

使用**protoc -I=. --go-grpc_out=paths=source_relative:gen/go trip.proto**生成grpc文件，定义的服务会生成client和server接口，与之前生成的文件配合使用。

要使用服务就需要实现接口。并且结构体要内嵌UnimplementedTripServiceServer。

```go
type Service struct {
	*trippb.UnimplementedTripServiceServer
}

func (*Service) GetTrip(ctx context.Context, req *trippb.GetTripRequest) (*trippb.GetTripResponse, error) 
```

UnimplementedTripServiceServer是为了向前兼容。因为它内部实现了接口，所以在接口方法改变后也不会报错。

###### server

需要net.Listen建立一个tcp连接，使用NewServer建立一个grpc的server，然后通过生成代码的RegisterTripServiceServer向服务中注册一个新的服务。trippb.RegisterTripServiceServer(s, &trip.Service{})

###### client

直接grpc.Dial建立连接，然后通过NewTripServiceClient建立客户端，之后使用方法即可。

#### Rest vs RPC

HTTP协议：方法，URL，Data

RPC：远程过程调用，使用就像调用方法一样简单。想把RPC暴露在网上，有两种风格的接口，一种直接RPC，一种是转换成REST。

RPC风格：Method只有Post，URL：api.server.com/GetTrip，Data

REST风格：使用HTTP动词来表示动作，URL为小写名词

​	C：POST api.server.com/trip Data:Json

​	R:GET api.service.com/trip/{id}

​	U:PUT api.service.com/trip/{id} Data:Json

​	D:DELETE  api.service.com/trip/{id}

#### grpc gate way

![image-20240108200100365](C:\Users\K9\OneDrive\图片\go笔记\coolcar\结构.png)

解析json，转换成二进制流。

不管内网使用什么，总要考虑向外暴露，总是需要一个代理来向外暴露。

gateway描述存放在yaml中。

固定格式：

selector是具体的服务名称，coolcar是proto里的package，下面的get是对应于服务暴露的接口。

```yaml
type: google.api.service
config_version: 3

http:
  rules:
  - selector: coolcar.TripService.GetTrip
    get: /trip/{id}
```

写完后需要生成代码

**protoc -I=. --grpc-gateway_out=paths=source_relative,grpc_api_configuration=trip.yaml:gen/go trip.proto**生成pb.gw.go文件。

##### 使用

```go
func startGRPCGateway() {
	c := context.Background()
	c, cancel := context.WithCancel(c)
	defer cancel()
	mux := runtime.NewServeMux()
	err := trippb.RegisterTripServiceHandlerFromEndpoint(c, mux, "localhost:8081", []grpc.DialOption{grpc.WithInsecure()})
	if err != nil {
		log.Fatalf("can not start grpc gateway:%v", err)
	}
	err = http.ListenAndServe(":8080", mux)
	if err != nil {
		log.Fatalf("can not listen and server:%v", err)
	}
}
```

服务是通过上下文来判断是否断开。RegisterTripServiceHandlerFromEndpoint就是把代理和服务连接起来。第一个参数是上下文，第二个参数是请求分发器，第三个参数是grpc服务的地址，第四个参数为连接方式。

之后启动gateway服务ttp.ListenAndServe(":8080", mux)。

#### 小程序访问grpc gateway

使用wx.Request去访问。

微信小程序需要事先设置通讯域名，只能和指定域名通信，不允许与本机IP通信。

可以在工具中选择不校验合法域名。

#### 数据类型统一填坑

由于proto中数字使用了int64，数据过大，所以自动转义成string，缩小为int32

枚举类型要特别注意统一，需要的是数字还是字符串。实际上需要传的一般是数字，但此时传的是字符串。需要转换就要在gateway的serverMux中加上marshaler参数，第一个参数是MIME资源类型，第二个使用JSONPb设置一下EnumAsInt,还可以设置很多东西，比如是否使用原始名称等。现在使用JSONPb需要先定义变量，在变量中去设置。

```go
m.UseEnumNumbers = true
m.UseProtoNames = true
mux :=runtime.NewServeMux(runtime.WithMarshalerOption(runtime.MIMEWildcard,
		m))
```

##### 为typescript引入proto中定义的结构

小程序需要引入一些包。

需要调整一下目录结构以便使用npm构建来导入包。

把node_module删除，小程序生成的typings删掉，这是小程序生成的类型。其中有一个index.d.ts是自己写的，把它搬到app.ts旁边。

package-lock.json是运行npm安装时生成的，删除。剩下的三个json文件移动到miniprogram下。

package.json中"miniprogramRoot": "miniprogram/",要删除，不然根目录就会变成miniprogram/miniprogram

tsconfig.json中"typeRoots": ["./typings" ]删除，它是去typings文件夹下去找类型的，以后就是"miniprogram-api-typings": "^2.8.3-1",拉下来的typings去找类型。

运行npm install

类型的寻找设置为"types": ["miniprogram-api-typings"],

##### 小程序请求的类型强化

接下来把protobuf转化成typescript代码，需要安装pbjs和pbts这两个工具。

去npm install protobufjs，^6.10.1版本会在.bin文件夹下生成pbjs和pbts

```bat
set PBTS_BIN_DIR=..\..\wx\miniprogram\node_modules\.bin
set PBTS_OUT_DIR=..\..\wx\miniprogram\service\proto_gen
%PBTS_BIN_DIR%\pbjs -t static -w es6 trip.proto --no-create --no-encode --no-decode --no-verify --no-delimited -o %PBTS_OUT_DIR%\trip_pb.js
echo Running pbts...
%PBTS_BIN_DIR%\pbts -o %PBTS_OUT_DIR%\trip_pb.d.ts %PBTS_OUT_DIR%\trip_pb.js
```

生成代码。

一直无法导入包，出错Uncaught SyntaxError: Unexpected token export。在编译选项中选择将js编译成ES5，之后把ts文件中import * as $protobuf from "protobufjs";复制到js中即可。

在请求成功后const getTripResp=coolcar.GetTripResponse.fromObject(res.data as object)会发现一些字段不见了，因为这些字段在生成的接口中是驼峰命名法，而在网络传输中使用的是下划线命名。所以无法识别。两个解决方案：1.在服务端规定使用驼峰命名对JSONPb设置m.UseProtoNames = false就会传递驼峰命名，但是这样与通常网络请求名称不符合；2.npm install camelcase-keys安装工具，onst getTripResp=coolcar.GetTripResponse.fromObject(camelcaseKeys(res.data as object,{Deep:true}))使用即可,deep表示深层也要转换。安装这种运行时依赖都需要在小程序中构建npm之后才能编译成功。

这样就能在小程序中直接使用.来获取成员。能解析出传过来的具体结构体。

使用脚本来把ts文件中import * as $protobuf from "protobufjs";复制到js中，生成的js先生成一个tmp，之后使用追加，追加到需要的文件中。

.gitignore中添加新的忽略规则 miniprogram_npm

### 微服务与存储设计+实战登录

#### 进一步理解微服务

##### 拆分服务后多出特性：

1.快速开发/迭代；2.自动化部署；3.独立部署；4.错误隔离；5.负载均衡；6.出错处理；7.链路跟踪；8.服务发现；9.服务治理；10.动态扩容；11.熔断，降级

系统复杂性增加，因为系统复杂性增加，所以要2,5,6,7,8,9

微服务的附属品：因为系统已经复杂了，所以把10,11也做了，因为10,11根据之前的特性更好做出来。

##### 微服务与领域驱动

到底应该划分为几个微服务。

划分领域，确定上下文边界，上下文映射，确定微服务边界。

看看系统有多少个领域。领域与上下文是对同一个事物不同角度，逻辑上看是领域，实现上看是上下文。边界内部可以有高耦合度。

#### 后端微服务划分

##### 领域划分

![image-20240110075257186](C:\Users\K9\OneDrive\图片\go笔记\coolcar\领域划分.png)

领域划分：行程类似于电商的商品，做一些行程管理。资格认证就涉及到照片管理。车辆管理前后台都需要。登录解决我是谁的问题，还解决权限问题。

确认上下文边界：行程需要知道我是谁，资格认证需要知道我是谁来拿取照片，车辆管理需要知道权限不关心是谁在做动作。照片管理里的权限等是完全与租车系统分开的，可能是与这个系统完全隔离开的；行程需要知道我又没有资格去开这个行程，行程和车辆管理有一个车辆状态的交互。

有了交互后，担心别的领域的概念会入侵，得到我是谁只得到一个id，不会入侵名字等概念。但是问有没有资格就完全不一样，如果是资格认证回答有没有资格开启一个行程，行程的概念就会入侵到资格认证中，如果是在行程领域中，用户认证状态就会入侵到行程中。行程和车辆同样有这种问题。登录系统不应该懂权限是什么，不应该为了权限做不同的逻辑。所以综合来说车辆状态和资格的传递是有概念的入侵，就可以把它们划分到一个服务中。

##### 微服务划分

![image-20240110080436472](C:\Users\K9\OneDrive\图片\go笔记\coolcar\微服务划分.png)

虽然划分到一个服务中，仍然要划分界限。

#### 登录

##### 过程分析

清空server目录。

在server下创建auth目录来实现登录服务。

wx.login静默登录会有一个code，request把code发到开发者服务器，开发者服务再向微信接口服务验证。具体流程在微信登录文档中。[开放能力 / 用户信息 / 小程序登录 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html)

auth就是为了实现微信文档中这个流程。

##### 定义proto与yaml

package 定义为auth.v1为了以后更新。

定义AuthService的服务，Login接口。

LoginRequest按照小程序的流程来包含code。Resp中返回自定义登录态Token和一个int32的过期时间。

这是一个Post请求。

在server下写一个genProto脚本来生成proto。

```bat
set PROTO_PATH=.\auth\api
set GO_OUT_PATH=.\auth\api\gen\v1
mkdir  %GO_OUT_PATH%
protoc -I=%PROTO_PATH% --go_out=paths=source_relative:%GO_OUT_PATH% auth.proto
protoc -I=%PROTO_PATH% --go-grpc_out=paths=source_relative:%GO_OUT_PATH% auth.proto
protoc -I=%PROTO_PATH% --grpc-gateway_out=paths=source_relative,grpc_api_configuration=%PROTO_PATH%\auth.yaml:%GO_OUT_PATH% auth.proto
set PBTS_BIN_DIR=..\wx\miniprogram\node_modules\.bin
set PBTS_OUT_DIR=..\wx\miniprogram\service\proto_gen
mkdir  %PBTS_OUT_DIR%
start %PBTS_BIN_DIR%\pbjs -t static -w es6 %PROTO_PATH%\auth.proto --no-create --no-encode --no-decode --no-verify --no-delimited -o %PBTS_OUT_DIR%\auth_pb_tmp.js
echo import * as ^$protobuf from "protobufjs"; > %PBTS_OUT_DIR%\auth_pb.js
type %PBTS_OUT_DIR%\auth_pb_tmp.js >> %PBTS_OUT_DIR%\auth_pb.js
del %PBTS_OUT_DIR%\auth_pb_tmp.js
start %PBTS_BIN_DIR%\pbts -o %PBTS_OUT_DIR%\auth_pb.d.ts %PBTS_OUT_DIR%\auth_pb.js
```

运行脚本生成。在auth下再建立一个auth文件夹来去实现服务。

##### 登录服务的框架

还需要一个在server根目录下gateway文件夹实现gateway服务。

使用 go get go.uber.org/zap去记录日志。

在service中要有个Logger *zap.Logger参数。

在根auth下建立main.go去开启一个登录服务来测试。在gateway目录下也需要启动一个gateway测试

使用wx.request测试log in 通不通。

##### 获取openId

在用户服务器把数据发给微信接口去获取openID。在auth.go定义接口OpenIDResolver定义方法Resolve(code string)(string,error)传入code获取openID。自然的Service中去包含这个接口。在Login中使用Resolve方法，如果出错不直接返回，返回status.Errorf()里面包含的东西就是想让用户看到的。

在auth下新建wechat目录去实现这个接口。具体实现在[小程序登录 / 小程序登录 (qq.com)](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html)接口描述。

使用github.com/medivhzhan/weapp/v2来使用go的一个微信包。

appId的值是project.config.json中的appId

AppSecret是在开发设置下的开发者ID下生成。

code是Resolve传入的，很重要不能明文报错。

都放入Service结构体中，而不是直接写死。这些在main.go中的注册服务时去配置

#### mongoDB

是一个json文档的数据库。对事务没有太大支持，没有Join。主要用于快速开发，ToC的系统，Serverless云开发。

##### docker启动MongoDB

docker pull mongo

docker run -p 27017:27017 --name mymongo -d mongo

拉取并启动mongoDB.

通过string 连接的方式mongodb://localhost:27017/coolcar?readPreference=primary&ssl=false可以指定数据库coolcar。

##### CRUD

只要user('databaseName')就能创建数据库

collection就是表。

###### insert

参数就是一个json文档

insertMany参数为一个json数组

###### delete

deleteone删除一个，使用id即可

###### find

使返回的是一个数组包含所有符合条件的记录

###### update

```sql
db.account.update({
    login_count:0,
},{
    $set:{
        login_count:1,
    }
})
```

增加的原子操作，保证操作安全。

```mongoDB
db.account.update({
    _id:ObjectId('65a5c7c5304f1b7033fbec92')
},{
   $inc:{
        login_count:1
   } 
})
```

##### 索引 查找

根据id查找

条件查找：

```sql
db.account.find({
    login_count:{$gte:1}
})
```

比如$gte就是大于等于，$or:[]  or里面是一个json条件数组

createIndex就是创建索引

##### 在playground模拟用户登录

```js
function resolveOpenId(open_id){
    return db.account.updateOne({
        open_id:open_id
    },{
        $set:{
            open_id:open_id
        }
    },{
        upsert:true,
    })
}
```

找到了就更新，这里是白更新，如果找不到由于upsert是true就会新建一个。但是这样只会返回一个json

```json
{
  "acknowledged": true,
  "insertedId": {
    "$oid": "65a67b7e486ae0f7c73683cf"
  },
  "matchedCount": 0,
  "modifiedCount": 0,
  "upsertedCount": 1
}
```

所以使用findAndModify

```js
function resolveOpenId(open_id){
    return db.account.findAndModify({
        query:{
            open_id:open_id
        },
        update:{
            $set:{
                open_id:open_id
            }
        },
        upsert:true,
        new:true//是否返回旧数据
    })
}
```

##### 通过go操作MongoDB

go.mongodb.org/mongo-driver/mongo

mongo.Connect来连接参数为一个context,另一个参数直接使用之前的string连接即可options.Client().ApplyURI("")。

#### 实现微信登录数据绑定

在auth文件夹下新建dao数据访问层。

定义Mongo结构体，在NewMongo时数据库由外界传入，但表名称由它自己写入。

用go实现之前写的ResolveOpenId改名为ResolveAccountId。使用FindOneAndUpdate。

找到后只需要它的id，所以只定义id解码，由于$set和open_id都是使用""包裹，是弱类型，之后会进行强类型限制。

先保证函数正确性，先通过test测试来测试函数逻辑正确性。

接下来进行前后端联调。

Service中加入*dao.Mongo,之后就在Login中去获得accountID，在main中新建mongo连接。

```go
type Mongo struct {
	col *mongo.Collection
}

func NewMongo(db *mongo.Database) *Mongo {
	return &Mongo{
		col: db.Collection("account"),
	}
}
func (m *Mongo) ResolveAccountID(c context.Context, openid string) (string, error) {
	res := m.col.FindOneAndUpdate(c, bson.M{
		"open_id": openid,
	}, bson.M{
		"$set": bson.M{
			"open_id": openid,
		},
	}, options.FindOneAndUpdate().SetUpsert(true).SetReturnDocument(options.After))
	if err := res.Err(); err != nil {
		return "", fmt.Errorf("canot FindOneAndUpdate %v", err)
	}
	var row struct {
		ID primitive.ObjectID `bson:"_id"`
	}
	err := res.Decode(&row)
	if err != nil {
		return "", fmt.Errorf("canot Decode %v", err)
	}
	return row.ID.Hex(), nil
}
```

**注意row中的ID一定要大写才能正确解码，不然只能解析出000.**

测试完成后就可以在main中建立连接并加入Mongo在小程序测试。

#### 数据绑定的代码重构

把open_id提取出来const openIdField="open_id"。

"$set"也要提取，并且想让其他的服务也可以使用这个，它是公用的。在server目录下加一个shared目录，下面加一个mongo目录存放公共的建立mongo.go。

存放Set方法去返回bson.M,传入的参数为一个接口类型。

ID的结构也是到处共用的，也提取到公共目录中，命名ObjID.

#### 使用go启动MongoDB并测试

##### 启动mongo

测试实例仍有很多问题，比如需要外部连接数据库，重启服务ID会变，多次运行只会get而不会新建，想要增加样例怎么办？

并且不想mock MongoDB,因为要测试FIndOneAndUpdate，要验证它的结果，需要尽量真实的环境。

要在测试开始的时候起一个MongoDB，它不会做任何的映射，数据不会保留。

github.com/docker/docker/client是docker的go语言包

需要先new一个client，通过client来创建一个容器。

config中配置镜像和ExposedPorts,ExposedPorts里面是nat.PortSet

接下来是hostconfig,里面包含PortBindings,里面是nat.PortMap

使用ContainerStart来启动容器

ContainerRemove来移除容器

```go
func main() {
	dc, err := client.NewClientWithOpts()
	if err != nil {
		log.Fatalf("fail new client %v", err)
	}
	c := context.Background()
	res, err := dc.ContainerCreate(c, &container.Config{
		Image: "mongo",
		ExposedPorts: nat.PortSet{
			"27017/tcp": {},
		},
	}, &container.HostConfig{
		PortBindings: nat.PortMap{
			"27017/tcp": []nat.PortBinding{
				{
					HostIP:   "127.0.0.1",
					HostPort: "0", //会自动寻找可用端口
				},
			},
		},
	}, nil, nil, "mongotest")
	if err != nil {
		log.Fatalf("fail new container %v", err)
	}
	err = dc.ContainerStart(c, res.ID, types.ContainerStartOptions{})
	if err != nil {
		log.Fatalf("fail start container %v", err)
	}
	inspRes, err := dc.ContainerInspect(c, res.ID)
	if err != nil {
		log.Fatalf("fail inspect container %v", err)
	}
	fmt.Printf("port map %v", inspRes.NetworkSettings.Ports["27017/tcp"])
	time.Sleep(3 * time.Second)
	dc.ContainerRemove(c, res.ID, types.ContainerRemoveOptions{Force: true})
}
```

##### 建立测试库

如何在运行测试前运行

使用TestMain(m *testing.M)。在m.Run之前把写好的启动程序贴过来。

需要把得到的端口告诉测试用例，只能通过全局变量来设置

既然每次测试都要启动连接，在shared下的mongo下新建testing文件夹，mongoTesting文件，定义RunWithMongoInDocker方法，把TestMain(m *testing.M)中的内容复制进来，return一个m.run。

mongoURI在RunWithMongoInDocker参数传入一个\*string 并在方法中赋值。TestMain中就直接os.Exit()来运行RunWithMongoInDocker。

```go
func NewWithMongoDocker(m *testing.M, mongoURI *string) int {
	dc, err := client.NewClientWithOpts()
	if err != nil {
		log.Fatalf("fail new client %v", err)
	}
	c := context.Background()
	res, err := dc.ContainerCreate(c, &container.Config{
		Image: image,
		ExposedPorts: nat.PortSet{
			containerPort: {},
		},
	}, &container.HostConfig{
		PortBindings: nat.PortMap{
			containerPort: []nat.PortBinding{
				{
					HostIP:   "127.0.0.1",
					HostPort: "0", //会自动寻找可用端口
				},
			},
		},
	}, nil, nil, "mongotest")
	if err != nil {
		log.Fatalf("fail new container %v", err)
	}
	defer func() {
		err := dc.ContainerRemove(c, res.ID, types.ContainerRemoveOptions{Force: true})
		if err != nil {
			panic(err)
		}
	}()
	err = dc.ContainerStart(c, res.ID, types.ContainerStartOptions{})
	if err != nil {
		log.Fatalf("fail start container %v", err)
	}
	inspRes, err := dc.ContainerInspect(c, res.ID)
	if err != nil {
		log.Fatalf("fail inspect container %v", err)
	}
	hostPort := inspRes.NetworkSettings.Ports[containerPort][0]
	*mongoURI = fmt.Sprintf("mongodb://%s:%s", hostPort.HostIP, hostPort.HostPort)
	return m.Run()
}
```



###### 解决测试错误

在Mongo中接受一个函数返回一个ObjectID,在测试中把Object的生成时使更换这个函数即可固定下ObjectID。

如果找到并不想update objectID所以不使用使用$set而是使用$setOnInsert,所以在共享的文件中新建方法SetOnInsert以替换Set方法。

##### 表格驱动测试

即使用testcases，先插入几行数据再去测试。

#### 登录阶段性总结

##### 微信登录

服务定义使用GRPC引领全栈开发。

获取openid使用微信API

存储openID，使用MongoDB存储

测试：使用docker来固定测试结果，表格驱动测试

### 权限设计与jwt

#### 自定义登录态

现在返回的登录态是一个明文token accountID。问题在于不安全。暴露后，可以被伪造来做一些事。

##### session

在以前，登录一般使用session，有一个session表，包含sessionID，accountID,登录时间，过期时间等。传的是sessionID。这种机制有一个性能问题，如果后续有很多服务需要知道我是谁，就都要去查session表，这就变成了一个性能瓶颈。因为HTTP每个请求都是无状态的，每个请求都要查找session表。

直接使用accountID性能很好，但是如何防止伪造？

##### JWT(json web token)

不需要维护任何状态数据；验证请求时直接验证签名；

安全问题：有效期内无法及时关停账户，因此有效期一般比较短，一两个小时

token只能由authService去颁发，authService想要颁发token，需要微信账号，登录微信

jwt.io了解jwt。

一个base64编码，任何人都能解析出head和payload的值。jwt的关键在VERIFY SIGNATURE，签名的组成是header加上payload的base64编码，加上自定义密码。

通过使用的密码学算法去获取签名内容。

##### 流程

用户登录取得accountID后,把accountID作为payloader的subject,后续字段任意。

标准字段：

sub:颁发给谁

iat：linux的秒数，表示什么时候颁发的。

iss：谁颁发的。

aud:用的工具。

exp:过期时间。

##### 实现

go get github.com/dhrijalva/jwt-go

###### 在auth.go中定义接口去使用。

```go
type TokenGenerator interface {
	GenerateToken(accountId string) (string, error)
}
```

定义JwtToken去实现接口，在设置时间时，为了便于测试，不在方法中加入time.Now而是在JwtToken中加入nowFunc () time.Time方法。

由于要设置过期时间，所以接口方法更改，增加参数过期时间。

```go
type TokenGenerator interface {
	GenerateToken(accountId string, expire time.Duration) (string, error)
}
```



key可以通过生成器去生成。

###### 将jwt配置好后，进行签名。

```go
type JwtTokenGen struct {
	issuer string
	nowFunc func() time.Time
	primaryKey *rsa.PrivateKey
}
func NewJwtTokenGen(issuer string)*JwtTokenGen{
	return &JwtTokenGen{
		issuer: issuer,
		nowFunc: time.Now,
	}
}
func (t *JwtTokenGen) GenerateToken(accountId string,expire time.Duration) (string, error) {
	now:=t.nowFunc().Unix()
	tkn:=jwt.NewWithClaims(jwt.SigningMethodRS512,jwt.StandardClaims{
		Subject:accountId,
		Issuer:t.issuer,
		IssuedAt:now,
		ExpiresAt:now+int64(expire.Seconds()),
	})
	return tkn.SignedString(t.primaryKey)
}
```

###### 在main.go中去集成

在注册服务时添加上新jwtGen,privateKey和publicKey先建立一个文件去保存。privateKey和AppSecret相同只是暂时保存，后续部署时会进行配置。

建立文件有个问题就是路径问题，该去哪里读，先暂时写为相对路径，**go的相对路径是相对于执行命令时的目录。**

##### 测试

这种没有外部依赖的适合测试。直接进行测试。

测试时先定义string把key放进去，使用jwt的parse来解析key，接下来就是New一个TokenGen，然后生成token，与jwt.io内的数据比较看是否相同。

```go
func TestGenerateToken(t *testing.T) {
	pk, err := jwt.ParseRSAPrivateKeyFromPEM([]byte(privateKey))
	if err != nil {
		t.Fatalf("cannot parse privateKey: %v", err)
	}
	g := NewJwtTokenGen("server/auth", pk)
	g.nowFunc = func() time.Time {
		return time.Unix(1516239022, 0)
	}
	tk, err := g.GenerateToken("65a713221b886d3a9bba21e3", 7200)
	if err != nil {
		t.Errorf("cannot generate token:%v", err)
	}
	want := "eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI2NWE3MTMyMjFiODg2ZDNhOWJiYTIxZTMiLCJpc3MiOiJzZXJ2ZXIvYXV0aCIsImlhdCI6MTUxNjIzOTAyMiwiZXhwIjoxNTE2MjQ2MjIyfQ.SY-lve-1Sa40GERUfJTY5T8TMZ0BOfuKUJd09l9J83JvpNgNE7KR9eGssTerKK8i5B6HsH2pYySJ3pbf1LZ-3XHVr-oWWOxsCHlLjwoo6GL_fua84xtthIDIyZEl6vEkmakfMYkysZS8BP97IGdM_MoVcD4hqvikW9BGh4D_5esVXOyohB-Bac5WJvip9gcCA3kBKtMYctTyXGatHTlySkZ6rXCjZV3rHkoG_5AJlEyfFNxaH1GUwHiExS97bTmCds4OXuDrTeOVssDHu729OPER_zkM1nMdm4tM7OOblmRb_LwsesGcgLS5bpnXAYp-OpMllva22bT6s-IIZ17cxQ"
	if tk != want {
		t.Fatalf("want :%s;got :%s", want, tk)
	}
}
```

不相同。

**因为jwt.io中字段顺序发生变化，在go中是按照字母排列的**

#### 发起请求时携带自定义登录态

显然的每个服务都要验证登录态，所以把验证写在一个公共的地方。

使用jwt.ParseWithClaims去解析出claim。

使用Valid属性验证签名，验证后再验证是否是StandardClaims,在使用Valid()方法验证属性。最后返回sub，即accountId

##### 测试

新建一组key，同样的先解析key，不过这次解析的是publickey。可以修改jwt.TimeFunc来修改时间以测试未过期或已过期的token。

测试四种情况：

1.正确的token

2.过期token

3.坏的token

4.错误的签名

#### 身份验证

##### Context

如订单系统

下单是在一个Context中，修改订单又是另一个Context中。Context也控制超时。

context.withTimeOut   withValue withCancel

##### Interceptor

所有服务都要验用户ID，所有请求都要走这个Interceptor，Interceptor就会想context中塞入用户ID。

公用的，写在公共目录中。

server下建立rental 租赁服务，这个服务是另一个微服务。

先建立一个简易的Trip。

更新脚本，就是把auth换成rental,就把之前的脚本写为一个genProto，$1就是第一个参数。

###### 创建拦截器

接下来就是从token中解出用户ID，之前已经实现，但是不能是Trip去调用，而是使用grpc Interceptor让请求来走。

在shared的auth下建立auth.go

拦截器的安装是在grpc.NewServer(grpc.UnaryInterceptor())。UnaryInterceptor是最简单的拦截器，它的参数是UnaryServerInterceptor类型，这是一个函数类型。

###### 实现一个UnaryServerInterceptor

要在auth.go中实现一个这个类型的函数,函数中做这样的处理：函数中去从ctx中获得token(**tokenFromCtx**)，之后去验证token，如果验证失败，那么token可能过期或伪造，最后return handler(ContextWithAccountId(aid),req)。ContextWithAccountId(ctx,aid)把ID塞到上下文中。IDFromContext函数是获得id的方法。

这里定义interceptor结构体，由于写在shared，不直接对外暴露而是暴露Interceptor，Interceptor接受publicKeyFile返回UnaryServerInterceptor和error。

根据函数实现，结构体中要包含publicKey，token验证再定义一个tokenVerify接口，由于jwttoken中已经包含publicKey，所以此结构体中就不用包含publicKey了。

```go
// Interceptor 传入公钥文件生成UnaryServerInterceptor
func Interceptor(publicKeyFile string) (grpc.UnaryServerInterceptor, error) {
	file, err := os.Open(publicKeyFile)
	if err != nil {
		return nil, fmt.Errorf("connot open public key file:%v", err)
	}
	pkBytes, err := io.ReadAll(file)
	if err != nil {
		return nil, fmt.Errorf("connot read public key file:%v", err)
	}
	pk, err := jwt.ParseRSAPublicKeyFromPEM(pkBytes)
	if err != nil {
		return nil, fmt.Errorf("connot parse public key :%v", err)
	}
	interceptor := interceptor{
		verifier: &token.JWTTokenVerify{
			PublicKey: pk,
		},
	}
	return interceptor.HandleReq, nil
}

type tokenVerfier interface {
	Verify(token string) (string, error)
}
type interceptor struct {
	verifier tokenVerfier
}
type accountIdKey struct {
}

// 处理请求
func (i *interceptor) HandleReq(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp any, err error) {
	tk, err := tokenFromCtx(ctx)
	if err != nil {
		return nil, status.Error(codes.Unauthenticated, "")
	}
	aid, err := i.verifier.Verify(tk)
	if err != nil {
		return nil, status.Errorf(codes.Unauthenticated, "token not valid : %v", err)
	}
	ctx = ContextWithAccountId(ctx, aid)
	return handler(ctx, req)
}

```



###### tokenFromCtx

从grpc的metadata，使用FromIncomingContext方法获取metadata.MD数据，MD类型为map[string] []string  它的key就是请求中的Header的键值。获取到authorization的值。

```go
func tokenFromCtx(ctx context.Context) (string, error) {
	unauthenticated := status.Error(codes.Unauthenticated, "")
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return "", unauthenticated
	}
	tkn := ""
	for _, v := range md["authorization"] {
		if strings.HasPrefix(v, "Bearer ") {
			tkn = v[len("Bearer "):]
		}
	}
	if tkn == "" {
		return "", unauthenticated
	}
	return tkn, nil
}
```



###### ContextWithAccountId

在建立一个accountIdKey的结构体作为key，不暴露，因为别人只需要知道可以从ctx中获得accountID。

```go
func ContextWithAccountId(ctx context.Context, accountId string) context.Context {
	return context.WithValue(ctx, accountIdKey{}, accountId)
}
func AccountIdFromContext(ctx context.Context) (string, error) {
	v := ctx.Value(accountIdKey{})
	aid, ok := v.(string)
	if !ok {
		return "", status.Error(codes.Unauthenticated, "")
	}
	return aid, nil
}
```

#### 新建立rental中的trip服务来测试身份验证

建立rental文件夹，类似auth去建立proto和yaml,然后去生成文件，建立Service实现服务，在启动服务时注册拦截器

```go
func main() {
	//组装zap日志
	logger, err := NewZapLog()
	if err != nil {
		log.Fatal("can not create zap log", logger)
	}
	n, err := net.Listen("tcp", ":8082")
	if err != nil {
		logger.Fatal("cannot listen", zap.Error(err))
	}
	in, err := auth.Interceptor("shared/auth/public.key")
	if err != nil {
		logger.Fatal("Interceptor listen", zap.Error(err))
	}
	s := grpc.NewServer(grpc.UnaryInterceptor(in))
	rentalpb.RegisterTripServiceServer(s, &trip.Service{
		Logger: logger,
	})
	err = s.Serve(n)
	if err != nil {
		logger.Fatal("cannot server", zap.Error(err))
	}
}
```

#### 自定义登录态存入storage与重试

也可存入内存。token还会过期，就需要重试机制

![image-20240223073924950](C:\Users\K9\OneDrive\图片\go笔记\coolcar\token重试.png)

最重要的是三个入口，两个业务请求和登录。

建立request.ts,把这些逻辑放在Coolcar命名空间中

首先要定义请求参数RequestOption接口，包含method,url,data,resp,data想要强类型，所以接口上有泛型<REQ>,resp是服务的Response,它就是之前实现的转化，所以resp改为respMarshller:(r:object)=>RES,泛型增加<REQ,RES>。

##### 先写下面的业务请求

sendRequest<REQ,RES>(o:RequestOption<REQ,RES>)Promise<RES>,他是不对外暴露的。在里面进行wx.request,数据内容跟之前的Request差不多，url,method,data,token其他是传入的，token只能找地方存，定义authData,token和ExpireIn放在这里。

login请求是要获取token，所以再添加接口AuthOption来判断是否附带token。sendRequest参数增加这个可选接口。

实现login，同样的把wx.login改为Promise<Wechat>,login设置为异步方法，里面先判断token是否有效，无效则使用wxLogin(),再进行sendRequest。最后把获得的token和过期时间存起来

再实现sendRequestWithAuthRetry,实际是个流程管理的函数，先login()登录，然后return sendRequest(o,a)

##### 重试

首先要定义一个err来判断是否是Auth的error，要先确保请求返回是我们定义的AUTH_ERR,这个错误在sendRequest的判断中，如果附带了token但是token过期则reject(AUTH_ERR)，在wx.request得到码如果为401则也reject(AUTH_ERR).

把sendRequestWithAuthRetry的内容加上try catch，如果有错并为AUTH_ERR就清除状态重试，AuthOption接口增加retryOnAuthError，来判断是否重试，在重试时把这个设为false

```ts
export namespace Coolcar{
    const serverAddr="http://localhost:8080"
    //token 信息
    const authData={
        token:'',
        expireMs:0
    }
    //身份验证错误
    const AUTH_ERR='AUTH_ERR'
    //请求发送数据接口
    export interface RequestOption<REQ,RES>{
        method:'PUT'|'POST'|'GET'|'DEL',
        path:string,
        data:REQ,
        respUnmarshaller:(r:object)=>RES
    }
    //是否包含token，失败是否重试
    interface AuthOption{
        RequestWithToken:boolean
        RetryIfFailed:boolean
    }
    export async function login(){
        if(authData.token&&authData.expireMs>=Date.now()){
            return
        }
        const wxResp=await wxLogin()
        const res= await sendRequest<auth.v1.ILoginRequest,auth.v1.ILoginResponse>({
                path:'/v1/auth/login',
                method:'POST',
                data:{
                    code:wxResp.code
                },
                respUnmarshaller:auth.v1.LoginResponse.fromObject
        },{RequestWithToken:false,RetryIfFailed:false})
        authData.token=res.accessToken!
        authData.expireMs=Date.now()+res.expireIn!*1000
    }

    export async function sendRequestWithAuthRetry<REQ,RES>(o:RequestOption<REQ,RES>,a?:AuthOption) :Promise<RES> {
        const authOpt=a||{
            RequestWithToken:true,
            RetryIfFailed:true
        }
        try{
            await login()
            return sendRequest(o,authOpt)
        }catch(err){
            if(err===AUTH_ERR&&authOpt.RetryIfFailed){
                    authData.token=''
                    authData.expireMs=0
                    return sendRequestWithAuthRetry(o,{
                        RequestWithToken:authOpt.RequestWithToken,
                        RetryIfFailed:false
                    })
            }else{
                throw err
            }
        }
    }
    function wxLogin():Promise<WechatMiniprogram.LoginSuccessCallbackResult>{
        return new Promise((resolve,reject)=>{
            wx.login({
                success:resolve,
                fail:reject
            })
        })
    }
    async function sendRequest<REQ,RES>(o:RequestOption<REQ,RES>,a:AuthOption) :Promise<RES> {
        return new Promise((resolve,reject)=>{
            const header:Record<string,any> ={}
            if(a.RequestWithToken===true){
                if(authData.token&&authData.expireMs>=Date.now()){
                    header.authorization='Bearer '+authData.token
                }else{
                    reject(AUTH_ERR)
                    return
                }
            }
            wx.request({
                url:serverAddr+o.path,
                method:'POST',
                data:o.data as WechatMiniprogram.IAnyObject,
                success:res=>{
                    if(res.statusCode===401){
                        reject(AUTH_ERR)
                    }else if(res.statusCode>=400){
                        reject(res)
                    }else{
                        resolve(o.respUnmarshaller(camelcaseKeys(res.data as object,{deep:true})))
                    }
                },
                header,
                fail:reject
            })
        })
    }
}
```

### 行程服务的标准化流程

#### 行程服务的定义

##### 数据定义

Trip服务数据包含account_id,car_id,start,end,current，status

start end current都是行程状态类型Locationstatus包含location fee_cent km_driven,poi_name

status为枚举类型TripStatus

**那么Trip包不包含id？**

value object vs entity

value object被认为一旦值变了就不是原来的value了，它是不可变的。 a=3  b=3虽然有两块内存，但他们值是相同的就认为他们是相等的。a=3  a=4，值变了就是a变了。location就作为value object,LocationStatus也作为value。

但是Trip就不作为值类型，它是一个实体，所以需要包含id。它内部的数据变了但它实体仍然没变，看是不是同一个trip只认id。

也可以定义一个TripEntity,放入id和Trip，这样Trip也是值类型，实体是TripEntity，这样在业务和技术上，Trip的意义就一致了。

##### 服务定义

CreateTrip,GetTrip,GetTrips

###### CreateTrip

创建服务CreaTripRequest应该传入什么，传入trip，如果Trip包含id,那么id该不该传入，虽然默认是生成但是定义上的逻辑看不出来。那么传入的Trip中的数据哪些该填哪些不该填该如何体现。那么就直接不传入Trip，只传入start和car_id，因为accountId是已经知道的。

返回可以返回id也可以返回Entity，这里采用Entity

###### GetTrip

通过id来查询

###### GetTrips

可以通过传入状态来查询指定状态的trip，也可以不填status全部查出来。返回什么呢，返回repeated TripEntity  因为Trip只是值，我们拿回很多Trip，我也不知道我有哪些trip，所以要带上id。

###### UpdateTrip

能改的只是Location的current，end_trip，汇报当前地点和是否结束当前行程。

#### 行程创建

##### 数据库

同样的先创建dao，来创建mongo文件。

类似于auth,这里实现先实现CreateTrip,在这里定义TripRecord结构，里面有id和trip，再加上一个UpdateAt,这个UpdateAt类似objId的添加，给它添加一个UpdatedAtField结构体来存放。

希望代码的结果可以是确定性的，所以在CreateTrip中的newObjId和time.Now()应该是定义一个变量，变量来存储函数，这样测试时可以更改函数。这样之前Mongo中存储的objId func() primitive.ObjectID就不再需要了。

这样定义由于TripRecord组合了IDField和UpdatedField，这样存入数据时会存入结构体，数据在结构体中，这样在TripRecord中组合时加上tag `bson"inline"`这样就会直接存入里面的内容。

```go
type Mongo struct {
	col *mongo.Collection
}

func NewMongo(db *mongo.Database) *Mongo {
	return &Mongo{
		col: db.Collection("trip"),
	}
}

type TripRecord struct {
	mgo.ObjIdField     `bson:"inline"`
	mgo.UpdatedAtField `bson:"inline"`
	Trip               *rentalpb.Trip `bson:"trip"`
}

func (m *Mongo) CreateTrip(ctx context.Context, trip *rentalpb.Trip) (*TripRecord, error) {
	t := &TripRecord{
		Trip: trip,
	}
	t.ID = mgo.NewObjId()
	t.UpdatedAt = mgo.NewUpdatedAt()
	_, err := m.col.InsertOne(ctx, t)
	if err != nil {
		return nil, err
	}
	return t, nil
}
```

##### 业务逻辑开发

1.验证资格；2.车辆开锁；3.创建数据，开始计费

验证资格需要资格认证，不能直接把资格认证里状态的概念拉入行程，所以行程中建立一个ACL层把别的领域的概念挡在ACL(防止入侵)层。

###### ACL层

定义ProfileManager接口包含Verify(context.Context,id.AccountID)error

只返回error，只告诉能不能继续做。

###### 创建行程业务

从上下文获取id，使用定义的Verify去验证身份。

比较怕Verify之后，点击重新验证，变成了另一个人。那就是Verify当前是什么状态就确定下来，**在资格认证或者ACL做一个快照，提供快照id，行程只要快照id。**

所以Verify返回值添加一个IdentityID。这样如果之后要追溯就能在ACL或者资格认证追溯到创建这个快照时的状态。Trip中添加一个IdentityID的保存。

一般在业务逻辑不是考虑分布式事务，而是考虑失败后如何补救。如果开锁后没有创建行程就非常危险。如果创建行程后开锁失败，严重性就小一些，后台可以补救。但是这样用户体验就不好。这样会导致，没有还车时，另一个人来扫码就会创建行程，开锁不成功。

**所以要先创建行程再开锁，创建行程前检查车辆状态**

创建CarManager接口，里面同样包含Verify方法，参数包含carID,判断车是否能用。还包含Unlock方法用来车辆解锁。

开锁时需要知道人的位置和车的位置，以保证状态。所以Verify中还要传入Location。

地点本应该是前端传入，这里简化，建立POIManager接口Resolver(ctx context.Context,*rentalpb.Location)(string,error)来根据当前坐标获取名称。这个出错后不返回error只输出Log。

开锁应该使用go func新建一个协程，并且上下文是新建一个BackGround，因为开锁可能是一个非常久的过程，需要去同步进行。

```go
type Service struct {
	Logger         *zap.Logger
	Mongo          *dao.Mongo
	ProfileManager ProfileManager
	CarManager     CarManager
	PoiManager     PoiManager
	rentalpb.UnimplementedTripServiceServer
}
type ProfileManager interface {
	Verify(ctx context.Context, id id.AccountId) (id.IndetityId, error)
}
type CarManager interface {
	Verify(ctx context.Context, id id.CarId, loc *rentalpb.Location) error
	UnLock(ctx context.Context, id id.CarId) error
}
type PoiManager interface {
	Resolve(ctx context.Context, loc *rentalpb.Location) (string, error)
}

func (s *Service) CreateTrip(ctx context.Context, req *rentalpb.CreateTripRequest) (*rentalpb.TripEntity, error) {
	aid, err := auth.AccountIdFromContext(ctx)
	if err != nil {
		return nil, err
	}
	iId, err := s.ProfileManager.Verify(ctx, aid)
	if err != nil {
		return nil, status.Error(codes.FailedPrecondition, "")
	}
	err = s.CarManager.Verify(ctx, id.CarId(req.CarId), req.Start.Location)
	if err != nil {
		return nil, status.Error(codes.FailedPrecondition, "")
	}
	poi, err := s.PoiManager.Resolve(ctx, req.Start.Location)
	if err != nil {
		s.Logger.Info("cannot resolve location to name", zap.Stringer("location", req.Start.Location))
	}
	start := &rentalpb.LocationStatus{
		Location: req.Start.Location,
		PoiName:  poi,
	}
	tr, err := s.Mongo.CreateTrip(ctx, &rentalpb.Trip{
		AccountId:  aid.String(),
		CarId:      req.CarId,
		Start:      start,
		Current:    start,
		IdentityId: iId.String(),
	})
	if err != nil {
		return nil, status.Error(codes.FailedPrecondition, "failed to create trip")
	}
	go func() {
		err := s.CarManager.UnLock(context.Background(), id.CarId(req.CarId))
		if err != nil {
			s.Logger.Warn("cannot unlock car", zap.Error(err))
		}
	}()
	return &rentalpb.TripEntity{
		Id:   tr.ID.Hex(),
		Trip: tr.Trip,
	}, nil
}
```

这个测试用例中主要测试的是认证错误，开锁错误等错误，因为发送请求数据的数据并没有很严格的规定。并且导致创建行程失败的一般都是前面的错误。所以数据不用在测试case中。

```go
func TestCreateTrip(t *testing.T) {
	s := &Service{}
	z, err := zap.NewDevelopment()
	if err != nil {
		t.Error("cannot create zap log", err.Error())
	}
	pm := &profileManager{
		ID: "identity1",
	}
	cm := &carManager{}
	pom := &poi.Manager{}
	s.ProfileManager = pm
	s.CarManager = cm
	s.PoiManager = pom
	s.Logger = z
	c := context.Background()
	c = auth.ContextWithAccountId(c, "account1")
	client, err := mongotesting.NewClient(c)
	if err != nil {
		t.Error("cannot create mongoclient")
	}
	s.Mongo = dao.NewMongo(client.Database("coolcar"))
	req := &rentalpb.CreateTripRequest{
		CarId: "car1",
		Start: &rentalpb.LocationStatus{
			Location: &rentalpb.Location{
				Latitude:  32.123,
				Longitude: 114.2525,
			},
		},
	}
	goldenRes := `{"account_id":"account1","car_id":"car1","start":{"location":{"latitude":32.123,"longitude":114.2525},"poi_name":"广州塔"},"current":{"location":{"latitude":32.123,"longitude":114.2525},"poi_name":"广州塔"},"identity_id":"identity1"}`

	testCases := []struct {
		name           string
		tripId         string
		profileError   error
		carVerifyError error
		carUnlockError error
		want           string
		wantErr        bool
	}{
		{
			name:   "normal_req",
			tripId: "65a713221b886d3a9bba21e5",
			want:   goldenRes,
		},
		{
			name:         "profileManager_error",
			tripId:       "65a713221b886d3a9bba21e6",
			wantErr:      true,
			profileError: fmt.Errorf("profile"),
		},
		{
			name:           "carVerify_error",
			tripId:         "65a713221b886d3a9bba21e7",
			wantErr:        true,
			carVerifyError: fmt.Errorf("carVerify"),
		},
		{
			name:           "carUnlock_error",
			tripId:         "65a713221b886d3a9bba21e8",
			carUnlockError: fmt.Errorf("carUnlock"),
			want:           goldenRes,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			mgo.NewObjIdWithValue(id.TripId(tc.tripId))
			pm.Err = tc.profileError
			cm.VerifyErr = tc.carVerifyError
			cm.UnlockErr = tc.carUnlockError
			te, err := s.CreateTrip(c, req)
			if tc.wantErr {
				if err == nil {
					t.Errorf("want err ;got nil")
				} else {
					return
				}
			}
			if err != nil {
				t.Errorf("connot create trip:%v", err)
			}
			b, err := json.Marshal(te.Trip)
			if err != nil {
				t.Errorf("cannot marshal to json:%v", err)
			}
			tripStr := string(b)
			if tc.want != tripStr {
				t.Errorf("incorrect res,want:%s,got:%s", tc.want, tripStr)
			}
		})
	}
}

type profileManager struct {
	ID  id.IndetityId
	Err error
}

func (p *profileManager) Verify(ctx context.Context, id id.AccountId) (id.IndetityId, error) {
	return p.ID, p.Err
}

type carManager struct {
	VerifyErr error
	UnlockErr error
}

func (c *carManager) Verify(ctx context.Context, id id.CarId, loc *rentalpb.Location) error {
	return c.VerifyErr
}
func (c *carManager) UnLock(ctx context.Context, id id.CarId) error {
	return c.UnlockErr
}
```

##### 前后端联调

同样先在client文件夹中把ACL两个接口实现一下，都先直接return nil，服务不出错就行。接下来就在微信前端修改一下开锁界面中的代码，修改一下之前实现的CreateTrip返回值，现在为TripEntity，再修改请求代码。

```typescript
onUnlockTap(){
    wx.getLocation({
      type:'gcj02',
      success:async loc=>{
        const trip= await TripService.CreateTrip({
          start:{
              longitude:loc.longitude,
              latitude:loc.latitude,
          },
          carId:this.carId
        })
        //TODO: 开锁，传值头像和经纬度
        wx.showLoading({
          title:'开锁中',
          mask:true,
        })
        setTimeout(() => {
          
          wx.redirectTo({
            url:routing.driving({
              trip_id: trip.id
            }),
            complete:()=>wx.hideLoading(),
          })
        },2000);
      },
      fail:()=>wx.showToast({
        icon:'none',
        title:"请前往设置页授权位置信息"
      })
    })
    
  },
```

但是在这里success之后CreateTrip成功，数据库里已经有了新建的数据但是页面没有跳转。

原因是

```typescript
    export function CreateTrip(req:rental.v1.ICreateTripRequest):Promise<rental.v1.ITripEntity>{
        return Coolcar.sendRequestWithAuthRetry({
                method:'POST',
                path:'/v1/trip/create',
                data:req,
                respUnmarshaller:rental.v1.TripEntity.fromObject
            },)
    }
```

之前在return中是return new Promise。但是，sendRequestWithAuthRetry本身就返回了Promise，所以这里并不用再return new Promise，并且之前错误添加的return new Promise没有用resolve输出值，导致没有值输出，导致trip为空。

#### 获取行程

GetTrip传入ctx,id,accountId,带上accountId的原因是确认这个id的trip确实是查询者的的。查询时有id和accountId两个查询条件。

#### 对于ID的进一步重构

shared目录下再开一个id。

在id中对每个id类型做操作。

```go
type AccountId string

func (a AccountId) String() string {
	return string(a)
}

type TripId string

func (a TripId) String() string {
	return string(a)
}
```

在mongo下再开一个objid,它用来对id做一个转换FromId(id fmt.Stringer)primative.ObjectID和ToAccountID,ToTripId

在代码替换各个类型的id，有特别的，比如GenerateToken传入的accountId就直接shiyString(),因为它不关心业务。

#### 保证同一个accout最多只能有一个进行中的Trip

通过unique index实现，关系型数据库也是这样实现。

通过建立accountid与status为key的唯一索引。

在mongoDB中设置参数unique=true,partialFilterExpression{"trip.status":1}这样保证"trip.status":1值为1的记录只有一个。

在mongo下建立setup.js文件，因为看上去像js的语法，这里把account的openid的唯一索引也加上。以便于服务器数据库部署。

#### 表格驱动测试

先改一下mongtesting中的代码，不再传入mongoURI的指针，而是新建NewClient和NewDefaultClient两个方法来返回mongoClient

再新加一个SetupIndexes方法来建立索引。

go get -u github.com/google/go-cmp/cmp

比较值和get的值是通过cmp.Diff(tr,got，protocom.Transform())来比较。

通过表格驱动测试create的索引，测试案例：

建立多个finished的记录成功；建立一个In_progress成功，再次建立IN_progress失败

#### 批量获取行程

有status不为Not_spec时才会联合status进行，查询。

查询时有一行decode出错的话，现在先直接返回出错，实际应该正常返回其他行。

可以再对id进行一个封装建立NewObjIdWithValue(id stringer)在里面给id的func赋值。

```go
func (m *Mongo) GetTrips(ctx context.Context, accountId id.AccountId, status rentalpb.TripStatus) ([]*TripRecord, error) {
	filter := bson.M{
		accountIdField: accountId,
	}
	if status != rentalpb.TripStatus_TS_NOT_SPECIFIED {
		filter[statusField] = status
	}
	c, err := m.col.Find(ctx, filter)
	if err != nil {
		return nil, err
	}
	var trips []*TripRecord
	for c.Next(ctx) {
		var trip TripRecord
		err = c.Decode(&trip)
		if err != nil {
			return nil, err
		}
		trips = append(trips, &trip)
	}
	return trips, nil
}

```

#### 更新行程

传入 tripid,accountid,UpdateAt,trip

传入UpdatedAt牵扯到乐观锁解决同时更新的问题。

去服务层，需要先GetTrip把Trip拿出来，这里的account需要从context中拿取。拿出来就就去修改它。

定义一个calcCurrentStatus(trip *rentalpb.Trip,cur *rentalpb.Location)*rentalpb.LocationStatus来计算当前的状态

做完很多业务计算后才能去update，如果同时更新这个trip，这个可能性非常小，因为有accountid的限制，所以使用乐观锁，就是这个updateAt落后时，这次更新就丢弃。

UpdateOne方法即使找不到记录也会成功返回，结果的MatchedCount为0.

mongo代码：

```go
func (m *Mongo) UpdateTrip(ctx context.Context, id id.TripId, aid id.AccountId, updatedAt int64, trip *rentalpb.Trip) error {
	objId, err := objid.FromId(id)
	if err != nil {
		return err
	}
	newUpdatedAt := mgo.NewUpdatedAt()
	res, err := m.col.UpdateOne(ctx, bson.M{
		mgo.IDFieldName:        objId,
		accountIdField:         aid.String(),
		mgo.UpdatedAtFieldName: updatedAt,
	}, mgo.Set(bson.M{
		tripField:              trip,
		mgo.UpdatedAtFieldName: newUpdatedAt,
	}),
	)
	if err != nil {
		return err
	}
	if res.MatchedCount == 0 {
		return fmt.Errorf("no match record")
	}
	return nil
}
```

